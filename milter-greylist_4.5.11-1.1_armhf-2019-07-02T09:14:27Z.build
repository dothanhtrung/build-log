sbuild (Debian sbuild) 0.78.1 (09 February 2019) on 4be29f1fdf49

+==============================================================================+
| milter-greylist 4.5.11-1.1 (armhf)           Tue, 02 Jul 2019 09:14:27 +0000 |
+==============================================================================+

Package: milter-greylist
Version: 4.5.11-1.1
Source Version: 4.5.11-1.1
Distribution: unstable-amd64-sbuild
Machine Architecture: amd64
Host Architecture: armhf
Build Architecture: amd64
Build Profiles: cross nocheck
Build Type: any

I: NOTICE: Log filtering will replace 'var/run/schroot/mount/unstable-amd64-sbuild-aa5c1dd4-45f4-42ff-9efd-05222d3ce779' with '<<CHROOT>>'
I: NOTICE: Log filtering will replace 'build/milter-greylist-xNbWVG/resolver-JBcyrw' with '<<RESOLVERDIR>>'

+------------------------------------------------------------------------------+
| Update chroot                                                                |
+------------------------------------------------------------------------------+

Hit:1 http://cdn-fastly.deb.debian.org/debian unstable InRelease
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
Calculating upgrade...
The following package was automatically installed and is no longer required:
  sensible-utils
Use 'apt autoremove' to remove it.
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.

+------------------------------------------------------------------------------+
| Fetch source files                                                           |
+------------------------------------------------------------------------------+


Local sources
-------------

/home/build/sbuild-setup/repo/pool/main/m/milter-greylist/milter-greylist_4.5.11-1.1.dsc exists in /home/build/sbuild-setup/repo/pool/main/m/milter-greylist; copying to chroot
I: NOTICE: Log filtering will replace 'build/milter-greylist-xNbWVG/milter-greylist-4.5.11' with '<<PKGBUILDDIR>>'
I: NOTICE: Log filtering will replace 'build/milter-greylist-xNbWVG' with '<<BUILDDIR>>'

+------------------------------------------------------------------------------+
| Install package build dependencies                                           |
+------------------------------------------------------------------------------+


Setup apt archive
-----------------

Merged Build-Depends: quilt, debhelper (>= 9), autotools-dev, libmilter-dev, bison, flex, libspf2-dev, libcurl4-openssl-dev, libopendkim-dev, libssl-dev, libgeoip-dev, libbind-dev, build-essential:amd64, fakeroot:amd64, crossbuild-essential-armhf:amd64, libc-dev:armhf, libstdc++-dev:armhf
Filtered Build-Depends: quilt, debhelper (>= 9), autotools-dev, libmilter-dev, bison, flex, libspf2-dev, libcurl4-openssl-dev, libopendkim-dev, libssl-dev, libgeoip-dev, libbind-dev, build-essential:amd64, fakeroot:amd64, crossbuild-essential-armhf:amd64, libc-dev:armhf, libstdc++-dev:armhf
dpkg-deb: building package 'sbuild-build-depends-main-dummy' in '/<<RESOLVERDIR>>/apt_archive/sbuild-build-depends-main-dummy.deb'.
Ign:1 copy:/<<RESOLVERDIR>>/apt_archive ./ InRelease
Get:2 copy:/<<RESOLVERDIR>>/apt_archive ./ Release [957 B]
Ign:3 copy:/<<RESOLVERDIR>>/apt_archive ./ Release.gpg
Get:4 copy:/<<RESOLVERDIR>>/apt_archive ./ Sources [453 B]
Get:5 copy:/<<RESOLVERDIR>>/apt_archive ./ Packages [540 B]
Fetched 1950 B in 0s (177 kB/s)
Reading package lists...
Reading package lists...

Install main build dependencies (apt-based resolver)
----------------------------------------------------

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following additional packages will be installed:
  autoconf automake autopoint autotools-dev binutils-arm-linux-gnueabihf bison
  bsdmainutils cpp-8-arm-linux-gnueabihf cpp-arm-linux-gnueabihf cross-config
  crossbuild-essential-armhf debhelper dh-autoreconf dh-strip-nondeterminism
  diffstat dpkg-cross dwz file flex g++-8-arm-linux-gnueabihf
  g++-arm-linux-gnueabihf gcc-8-arm-linux-gnueabihf
  gcc-8-arm-linux-gnueabihf-base gcc-8-base:armhf gcc-8-cross-base
  gcc-arm-linux-gnueabihf geoip-bin gettext gettext-base groff-base
  intltool-debian libarchive-zip-perl libasan5:armhf libasan5-armhf-cross
  libatomic1:armhf libatomic1-armhf-cross libbind-dev:armhf libbind9-161:armhf
  libbsd0 libbsd0:armhf libc6:armhf libc6-armhf-cross libc6-dev:armhf
  libc6-dev-armhf-cross libcap2:armhf libcom-err2:armhf libconfig-auto-perl
  libconfig-inifiles-perl libcroco3 libcurl4:armhf libcurl4-openssl-dev:armhf
  libdb5.3:armhf libdebian-dpkgcross-perl libdns1104:armhf libffi6:armhf
  libfile-homedir-perl libfile-stripnondeterminism-perl libfile-which-perl
  libfstrm0:armhf libgcc-8-dev:armhf libgcc-8-dev-armhf-cross libgcc1:armhf
  libgcc1-armhf-cross libgcrypt20:armhf libgeoip-dev:armhf libgeoip1
  libgeoip1:armhf libglib2.0-0 libgmp10:armhf libgnutls30:armhf libgomp1:armhf
  libgomp1-armhf-cross libgpg-error0:armhf libgssapi-krb5-2:armhf
  libhogweed4:armhf libicu63 libicu63:armhf libidn2-0:armhf libio-string-perl
  libirs161:armhf libisc1100:armhf libisccc161:armhf libisccfg163:armhf
  libjson-c3:armhf libk5crypto3:armhf libkeyutils1:armhf libkrb5-3:armhf
  libkrb5support0:armhf libldap-2.4-2:armhf liblmdb0:armhf
  liblocale-gettext-perl liblwres161:armhf liblzma5:armhf libmagic-mgc
  libmagic1 libmilter-dev:armhf libmilter1.0.1:armhf libncurses6
  libnettle6:armhf libnghttp2-14:armhf libopendkim-dev:armhf
  libopendkim11:armhf libp11-kit0:armhf libpipeline1 libprotobuf-c1:armhf
  libpsl5:armhf librtmp1:armhf libsasl2-2:armhf libsasl2-modules-db:armhf
  libsigsegv2 libspf2-2:armhf libspf2-dev:armhf libssh2-1:armhf
  libssl-dev:armhf libssl1.1:armhf libstdc++-8-dev:armhf
  libstdc++-8-dev-armhf-cross libstdc++6:armhf libstdc++6-armhf-cross
  libtasn1-6:armhf libtool libubsan1:armhf libubsan1-armhf-cross libuchardet0
  libunistring2:armhf libxml-libxml-perl libxml-namespacesupport-perl
  libxml-sax-base-perl libxml-sax-perl libxml-simple-perl libxml2
  libxml2:armhf libyaml-perl linux-libc-dev:armhf linux-libc-dev-armhf-cross
  m4 man-db po-debconf quilt ucf zlib1g:armhf
Suggested packages:
  autoconf-archive gnu-standards autoconf-doc binutils-doc bison-doc wamerican
  | wordlist whois vacation gcc-8-locales cpp-doc dh-make binutils-multiarch
  flex-doc gcc-8-doc libstdc++6-8-dbg-armhf-cross libgcc1-dbg-armhf-cross
  libgomp1-dbg-armhf-cross libitm1-dbg-armhf-cross libatomic1-dbg-armhf-cross
  libasan5-dbg-armhf-cross liblsan0-dbg-armhf-cross libtsan0-dbg-armhf-cross
  libubsan1-dbg-armhf-cross libmpx2-dbg-armhf-cross
  libquadmath0-dbg-armhf-cross manpages-dev gdb-arm-linux-gnueabihf gcc-doc
  gettext-doc libasprintf-dev libgettextpo-dev groff glibc-doc:armhf
  libc-l10n:armhf locales:armhf manpages-dev:armhf libcurl4-doc:armhf
  libidn11-dev:armhf libkrb5-dev:armhf libldap2-dev:armhf librtmp-dev:armhf
  libssh2-1-dev:armhf pkg-config:armhf zlib1g-dev:armhf rng-tools:armhf
  gnutls-bin:armhf krb5-doc:armhf krb5-user:armhf sendmail-doc:armhf
  libssl-doc:armhf libstdc++-8-doc:armhf libtool-doc gfortran
  | fortran95-compiler gcj-jdk libyaml-shell-perl m4-doc apparmor less
  www-browser libmail-box-perl default-mta | mail-transport-agent graphviz
  procmail
Recommended packages:
  libfl-dev curl | wget | lynx ca-certificates:armhf libarchive-cpio-perl
  geoip-database geoip-database:armhf libglib2.0-data shared-mime-info
  xdg-user-dirs libgpg-error-l10n:armhf krb5-locales:armhf libgpm2
  publicsuffix:armhf libsasl2-modules:armhf libltdl-dev libwww-perl
  libxml-sax-expat-perl libyaml-libyaml-perl | libyaml-syck-perl
  libmail-sendmail-perl less
The following NEW packages will be installed:
  autoconf automake autopoint autotools-dev binutils-arm-linux-gnueabihf bison
  bsdmainutils cpp-8-arm-linux-gnueabihf cpp-arm-linux-gnueabihf cross-config
  crossbuild-essential-armhf debhelper dh-autoreconf dh-strip-nondeterminism
  diffstat dpkg-cross dwz file flex g++-8-arm-linux-gnueabihf
  g++-arm-linux-gnueabihf gcc-8-arm-linux-gnueabihf
  gcc-8-arm-linux-gnueabihf-base gcc-8-base:armhf gcc-8-cross-base
  gcc-arm-linux-gnueabihf geoip-bin gettext gettext-base groff-base
  intltool-debian libarchive-zip-perl libasan5:armhf libasan5-armhf-cross
  libatomic1:armhf libatomic1-armhf-cross libbind-dev:armhf libbind9-161:armhf
  libbsd0 libbsd0:armhf libc6:armhf libc6-armhf-cross libc6-dev:armhf
  libc6-dev-armhf-cross libcap2:armhf libcom-err2:armhf libconfig-auto-perl
  libconfig-inifiles-perl libcroco3 libcurl4:armhf libcurl4-openssl-dev:armhf
  libdb5.3:armhf libdebian-dpkgcross-perl libdns1104:armhf libffi6:armhf
  libfile-homedir-perl libfile-stripnondeterminism-perl libfile-which-perl
  libfstrm0:armhf libgcc-8-dev:armhf libgcc-8-dev-armhf-cross libgcc1:armhf
  libgcc1-armhf-cross libgcrypt20:armhf libgeoip-dev:armhf libgeoip1
  libgeoip1:armhf libglib2.0-0 libgmp10:armhf libgnutls30:armhf libgomp1:armhf
  libgomp1-armhf-cross libgpg-error0:armhf libgssapi-krb5-2:armhf
  libhogweed4:armhf libicu63 libicu63:armhf libidn2-0:armhf libio-string-perl
  libirs161:armhf libisc1100:armhf libisccc161:armhf libisccfg163:armhf
  libjson-c3:armhf libk5crypto3:armhf libkeyutils1:armhf libkrb5-3:armhf
  libkrb5support0:armhf libldap-2.4-2:armhf liblmdb0:armhf
  liblocale-gettext-perl liblwres161:armhf liblzma5:armhf libmagic-mgc
  libmagic1 libmilter-dev:armhf libmilter1.0.1:armhf libncurses6
  libnettle6:armhf libnghttp2-14:armhf libopendkim-dev:armhf
  libopendkim11:armhf libp11-kit0:armhf libpipeline1 libprotobuf-c1:armhf
  libpsl5:armhf librtmp1:armhf libsasl2-2:armhf libsasl2-modules-db:armhf
  libsigsegv2 libspf2-2:armhf libspf2-dev:armhf libssh2-1:armhf
  libssl-dev:armhf libssl1.1:armhf libstdc++-8-dev:armhf
  libstdc++-8-dev-armhf-cross libstdc++6:armhf libstdc++6-armhf-cross
  libtasn1-6:armhf libtool libubsan1:armhf libubsan1-armhf-cross libuchardet0
  libunistring2:armhf libxml-libxml-perl libxml-namespacesupport-perl
  libxml-sax-base-perl libxml-sax-perl libxml-simple-perl libxml2
  libxml2:armhf libyaml-perl linux-libc-dev:armhf linux-libc-dev-armhf-cross
  m4 man-db po-debconf quilt sbuild-build-depends-main-dummy:armhf ucf
  zlib1g:armhf
0 upgraded, 142 newly installed, 0 to remove and 0 not upgraded.
Need to get 6401 kB/85.2 MB of archives.
After this operation, 306 MB of additional disk space will be used.
Get:1 copy:/<<RESOLVERDIR>>/apt_archive ./ sbuild-build-depends-main-dummy 0.invalid.0 [968 B]
Get:2 http://cdn-fastly.deb.debian.org/debian unstable/main amd64 libgeoip1 amd64 1.6.12-1 [93.1 kB]
Get:3 http://cdn-fastly.deb.debian.org/debian unstable/main amd64 geoip-bin amd64 1.6.12-1 [67.4 kB]
Get:4 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libfstrm0 armhf 0.4.0-1 [17.1 kB]
Get:5 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libgeoip1 armhf 1.6.12-1 [86.9 kB]
Get:6 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libjson-c3 armhf 0.12.1+ds-2 [24.9 kB]
Get:7 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libprotobuf-c1 armhf 1.3.1-1+b1 [24.3 kB]
Get:8 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libisc1100 armhf 1:9.11.5.P4+dfsg-5.1 [427 kB]
Get:9 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libdns1104 armhf 1:9.11.5.P4+dfsg-5.1 [1100 kB]
Get:10 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libisccc161 armhf 1:9.11.5.P4+dfsg-5.1 [234 kB]
Get:11 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libisccfg163 armhf 1:9.11.5.P4+dfsg-5.1 [258 kB]
Get:12 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libbind9-161 armhf 1:9.11.5.P4+dfsg-5.1 [244 kB]
Get:13 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libirs161 armhf 1:9.11.5.P4+dfsg-5.1 [235 kB]
Get:14 http://cdn-fastly.deb.debian.org/debian unstable/main armhf liblwres161 armhf 1:9.11.5.P4+dfsg-5.1 [247 kB]
Get:15 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libbind-dev armhf 1:9.11.5.P4+dfsg-5.1 [1666 kB]
Get:16 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libcurl4 armhf 7.64.0-4 [297 kB]
Get:17 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libcurl4-openssl-dev armhf 7.64.0-4 [390 kB]
Get:18 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libgeoip-dev armhf 1.6.12-1 [105 kB]
Get:19 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libmilter1.0.1 armhf 8.15.2-12 [242 kB]
Get:20 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libmilter-dev armhf 8.15.2-12 [298 kB]
Get:21 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libopendkim11 armhf 2.11.0~alpha-12 [84.1 kB]
Get:22 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libopendkim-dev armhf 2.11.0~alpha-12 [154 kB]
Get:23 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libspf2-2 armhf 1.2.10-7+b5 [49.5 kB]
Get:24 http://cdn-fastly.deb.debian.org/debian unstable/main armhf libspf2-dev armhf 1.2.10-7+b5 [54.7 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 6401 kB in 8s (756 kB/s)
Selecting previously unselected package libbsd0:amd64.
(Reading database ... 12449 files and directories currently installed.)
Preparing to unpack .../000-libbsd0_0.9.1-2_amd64.deb ...
Unpacking libbsd0:amd64 (0.9.1-2) ...
Selecting previously unselected package bsdmainutils.
Preparing to unpack .../001-bsdmainutils_11.1.2+b1_amd64.deb ...
Unpacking bsdmainutils (11.1.2+b1) ...
Selecting previously unselected package libuchardet0:amd64.
Preparing to unpack .../002-libuchardet0_0.0.6-3_amd64.deb ...
Unpacking libuchardet0:amd64 (0.0.6-3) ...
Selecting previously unselected package groff-base.
Preparing to unpack .../003-groff-base_1.22.4-3_amd64.deb ...
Unpacking groff-base (1.22.4-3) ...
Selecting previously unselected package libpipeline1:amd64.
Preparing to unpack .../004-libpipeline1_1.5.1-2_amd64.deb ...
Unpacking libpipeline1:amd64 (1.5.1-2) ...
Selecting previously unselected package man-db.
Preparing to unpack .../005-man-db_2.8.5-2_amd64.deb ...
Unpacking man-db (2.8.5-2) ...
Selecting previously unselected package libsigsegv2:amd64.
Preparing to unpack .../006-libsigsegv2_2.12-2_amd64.deb ...
Unpacking libsigsegv2:amd64 (2.12-2) ...
Selecting previously unselected package m4.
Preparing to unpack .../007-m4_1.4.18-2_amd64.deb ...
Unpacking m4 (1.4.18-2) ...
Selecting previously unselected package flex.
Preparing to unpack .../008-flex_2.6.4-6.2_amd64.deb ...
Unpacking flex (2.6.4-6.2) ...
Selecting previously unselected package liblocale-gettext-perl.
Preparing to unpack .../009-liblocale-gettext-perl_1.07-3+b4_amd64.deb ...
Unpacking liblocale-gettext-perl (1.07-3+b4) ...
Selecting previously unselected package libmagic-mgc.
Preparing to unpack .../010-libmagic-mgc_1%3a5.35-4_amd64.deb ...
Unpacking libmagic-mgc (1:5.35-4) ...
Selecting previously unselected package libmagic1:amd64.
Preparing to unpack .../011-libmagic1_1%3a5.35-4_amd64.deb ...
Unpacking libmagic1:amd64 (1:5.35-4) ...
Selecting previously unselected package file.
Preparing to unpack .../012-file_1%3a5.35-4_amd64.deb ...
Unpacking file (1:5.35-4) ...
Selecting previously unselected package gettext-base.
Preparing to unpack .../013-gettext-base_0.19.8.1-9_amd64.deb ...
Unpacking gettext-base (0.19.8.1-9) ...
Selecting previously unselected package ucf.
Preparing to unpack .../014-ucf_3.0038+nmu1_all.deb ...
Moving old data out of the way
Unpacking ucf (3.0038+nmu1) ...
Selecting previously unselected package autoconf.
Preparing to unpack .../015-autoconf_2.69-11_all.deb ...
Unpacking autoconf (2.69-11) ...
Selecting previously unselected package autotools-dev.
Preparing to unpack .../016-autotools-dev_20180224.1_all.deb ...
Unpacking autotools-dev (20180224.1) ...
Selecting previously unselected package automake.
Preparing to unpack .../017-automake_1%3a1.16.1-4_all.deb ...
Unpacking automake (1:1.16.1-4) ...
Selecting previously unselected package autopoint.
Preparing to unpack .../018-autopoint_0.19.8.1-9_all.deb ...
Unpacking autopoint (0.19.8.1-9) ...
Selecting previously unselected package binutils-arm-linux-gnueabihf.
Preparing to unpack .../019-binutils-arm-linux-gnueabihf_2.31.1-16_amd64.deb ...
Unpacking binutils-arm-linux-gnueabihf (2.31.1-16) ...
Selecting previously unselected package bison.
Preparing to unpack .../020-bison_2%3a3.4.1+dfsg-2_amd64.deb ...
Unpacking bison (2:3.4.1+dfsg-2) ...
Selecting previously unselected package gcc-8-arm-linux-gnueabihf-base:amd64.
Preparing to unpack .../021-gcc-8-arm-linux-gnueabihf-base_8.3.0-7cross1_amd64.deb ...
Unpacking gcc-8-arm-linux-gnueabihf-base:amd64 (8.3.0-7cross1) ...
Selecting previously unselected package cpp-8-arm-linux-gnueabihf.
Preparing to unpack .../022-cpp-8-arm-linux-gnueabihf_8.3.0-7cross1_amd64.deb ...
Unpacking cpp-8-arm-linux-gnueabihf (8.3.0-7cross1) ...
Selecting previously unselected package cpp-arm-linux-gnueabihf.
Preparing to unpack .../023-cpp-arm-linux-gnueabihf_4%3a8.3.0-1_amd64.deb ...
Unpacking cpp-arm-linux-gnueabihf (4:8.3.0-1) ...
Selecting previously unselected package cross-config.
Preparing to unpack .../024-cross-config_2.6.15-3_all.deb ...
Unpacking cross-config (2.6.15-3) ...
Selecting previously unselected package gcc-8-cross-base.
Preparing to unpack .../025-gcc-8-cross-base_8.3.0-7cross1_all.deb ...
Unpacking gcc-8-cross-base (8.3.0-7cross1) ...
Selecting previously unselected package libc6-armhf-cross.
Preparing to unpack .../026-libc6-armhf-cross_2.28-10cross2_all.deb ...
Unpacking libc6-armhf-cross (2.28-10cross2) ...
Selecting previously unselected package libgcc1-armhf-cross.
Preparing to unpack .../027-libgcc1-armhf-cross_1%3a8.3.0-7cross1_all.deb ...
Unpacking libgcc1-armhf-cross (1:8.3.0-7cross1) ...
Selecting previously unselected package libgomp1-armhf-cross.
Preparing to unpack .../028-libgomp1-armhf-cross_8.3.0-7cross1_all.deb ...
Unpacking libgomp1-armhf-cross (8.3.0-7cross1) ...
Selecting previously unselected package libatomic1-armhf-cross.
Preparing to unpack .../029-libatomic1-armhf-cross_8.3.0-7cross1_all.deb ...
Unpacking libatomic1-armhf-cross (8.3.0-7cross1) ...
Selecting previously unselected package libstdc++6-armhf-cross.
Preparing to unpack .../030-libstdc++6-armhf-cross_8.3.0-7cross1_all.deb ...
Unpacking libstdc++6-armhf-cross (8.3.0-7cross1) ...
Selecting previously unselected package libasan5-armhf-cross.
Preparing to unpack .../031-libasan5-armhf-cross_8.3.0-7cross1_all.deb ...
Unpacking libasan5-armhf-cross (8.3.0-7cross1) ...
Selecting previously unselected package libubsan1-armhf-cross.
Preparing to unpack .../032-libubsan1-armhf-cross_8.3.0-7cross1_all.deb ...
Unpacking libubsan1-armhf-cross (8.3.0-7cross1) ...
Selecting previously unselected package libgcc-8-dev-armhf-cross.
Preparing to unpack .../033-libgcc-8-dev-armhf-cross_8.3.0-7cross1_all.deb ...
Unpacking libgcc-8-dev-armhf-cross (8.3.0-7cross1) ...
Selecting previously unselected package gcc-8-arm-linux-gnueabihf.
Preparing to unpack .../034-gcc-8-arm-linux-gnueabihf_8.3.0-7cross1_amd64.deb ...
Unpacking gcc-8-arm-linux-gnueabihf (8.3.0-7cross1) ...
Selecting previously unselected package gcc-arm-linux-gnueabihf.
Preparing to unpack .../035-gcc-arm-linux-gnueabihf_4%3a8.3.0-1_amd64.deb ...
Unpacking gcc-arm-linux-gnueabihf (4:8.3.0-1) ...
Selecting previously unselected package linux-libc-dev-armhf-cross.
Preparing to unpack .../036-linux-libc-dev-armhf-cross_4.19.28-2cross2_all.deb ...
Unpacking linux-libc-dev-armhf-cross (4.19.28-2cross2) ...
Selecting previously unselected package libc6-dev-armhf-cross.
Preparing to unpack .../037-libc6-dev-armhf-cross_2.28-10cross2_all.deb ...
Unpacking libc6-dev-armhf-cross (2.28-10cross2) ...
Selecting previously unselected package libstdc++-8-dev-armhf-cross.
Preparing to unpack .../038-libstdc++-8-dev-armhf-cross_8.3.0-7cross1_all.deb ...
Unpacking libstdc++-8-dev-armhf-cross (8.3.0-7cross1) ...
Selecting previously unselected package g++-8-arm-linux-gnueabihf.
Preparing to unpack .../039-g++-8-arm-linux-gnueabihf_8.3.0-7cross1_amd64.deb ...
Unpacking g++-8-arm-linux-gnueabihf (8.3.0-7cross1) ...
Selecting previously unselected package g++-arm-linux-gnueabihf.
Preparing to unpack .../040-g++-arm-linux-gnueabihf_4%3a8.3.0-1_amd64.deb ...
Unpacking g++-arm-linux-gnueabihf (4:8.3.0-1) ...
Selecting previously unselected package libconfig-inifiles-perl.
Preparing to unpack .../041-libconfig-inifiles-perl_3.000001-1_all.deb ...
Unpacking libconfig-inifiles-perl (3.000001-1) ...
Selecting previously unselected package libio-string-perl.
Preparing to unpack .../042-libio-string-perl_1.08-3_all.deb ...
Unpacking libio-string-perl (1.08-3) ...
Selecting previously unselected package libicu63:amd64.
Preparing to unpack .../043-libicu63_63.2-2_amd64.deb ...
Unpacking libicu63:amd64 (63.2-2) ...
Selecting previously unselected package libxml2:amd64.
Preparing to unpack .../044-libxml2_2.9.4+dfsg1-7+b3_amd64.deb ...
Unpacking libxml2:amd64 (2.9.4+dfsg1-7+b3) ...
Selecting previously unselected package libxml-namespacesupport-perl.
Preparing to unpack .../045-libxml-namespacesupport-perl_1.12-1_all.deb ...
Unpacking libxml-namespacesupport-perl (1.12-1) ...
Selecting previously unselected package libxml-sax-base-perl.
Preparing to unpack .../046-libxml-sax-base-perl_1.09-1_all.deb ...
Unpacking libxml-sax-base-perl (1.09-1) ...
Selecting previously unselected package libxml-sax-perl.
Preparing to unpack .../047-libxml-sax-perl_1.00+dfsg-1_all.deb ...
Unpacking libxml-sax-perl (1.00+dfsg-1) ...
Selecting previously unselected package libxml-libxml-perl.
Preparing to unpack .../048-libxml-libxml-perl_2.0134+dfsg-1_amd64.deb ...
Unpacking libxml-libxml-perl (2.0134+dfsg-1) ...
Selecting previously unselected package libxml-simple-perl.
Preparing to unpack .../049-libxml-simple-perl_2.25-1_all.deb ...
Unpacking libxml-simple-perl (2.25-1) ...
Selecting previously unselected package libyaml-perl.
Preparing to unpack .../050-libyaml-perl_1.27-1_all.deb ...
Unpacking libyaml-perl (1.27-1) ...
Selecting previously unselected package libconfig-auto-perl.
Preparing to unpack .../051-libconfig-auto-perl_0.44-1_all.deb ...
Unpacking libconfig-auto-perl (0.44-1) ...
Selecting previously unselected package libfile-which-perl.
Preparing to unpack .../052-libfile-which-perl_1.23-1_all.deb ...
Unpacking libfile-which-perl (1.23-1) ...
Selecting previously unselected package libfile-homedir-perl.
Preparing to unpack .../053-libfile-homedir-perl_1.004-1_all.deb ...
Unpacking libfile-homedir-perl (1.004-1) ...
Selecting previously unselected package libdebian-dpkgcross-perl.
Preparing to unpack .../054-libdebian-dpkgcross-perl_2.6.15-3_all.deb ...
Unpacking libdebian-dpkgcross-perl (2.6.15-3) ...
Selecting previously unselected package dpkg-cross.
Preparing to unpack .../055-dpkg-cross_2.6.15-3_all.deb ...
Unpacking dpkg-cross (2.6.15-3) ...
Selecting previously unselected package crossbuild-essential-armhf.
Preparing to unpack .../056-crossbuild-essential-armhf_12.6_all.deb ...
Unpacking crossbuild-essential-armhf (12.6) ...
Selecting previously unselected package libtool.
Preparing to unpack .../057-libtool_2.4.6-10_all.deb ...
Unpacking libtool (2.4.6-10) ...
Selecting previously unselected package dh-autoreconf.
Preparing to unpack .../058-dh-autoreconf_19_all.deb ...
Unpacking dh-autoreconf (19) ...
Selecting previously unselected package libarchive-zip-perl.
Preparing to unpack .../059-libarchive-zip-perl_1.64-1_all.deb ...
Unpacking libarchive-zip-perl (1.64-1) ...
Selecting previously unselected package libfile-stripnondeterminism-perl.
Preparing to unpack .../060-libfile-stripnondeterminism-perl_1.1.2-1_all.deb ...
Unpacking libfile-stripnondeterminism-perl (1.1.2-1) ...
Selecting previously unselected package dh-strip-nondeterminism.
Preparing to unpack .../061-dh-strip-nondeterminism_1.1.2-1_all.deb ...
Unpacking dh-strip-nondeterminism (1.1.2-1) ...
Selecting previously unselected package dwz.
Preparing to unpack .../062-dwz_0.12-3_amd64.deb ...
Unpacking dwz (0.12-3) ...
Selecting previously unselected package libglib2.0-0:amd64.
Preparing to unpack .../063-libglib2.0-0_2.58.3-2_amd64.deb ...
Unpacking libglib2.0-0:amd64 (2.58.3-2) ...
Selecting previously unselected package libcroco3:amd64.
Preparing to unpack .../064-libcroco3_0.6.12-3_amd64.deb ...
Unpacking libcroco3:amd64 (0.6.12-3) ...
Selecting previously unselected package libncurses6:amd64.
Preparing to unpack .../065-libncurses6_6.1+20181013-2_amd64.deb ...
Unpacking libncurses6:amd64 (6.1+20181013-2) ...
Selecting previously unselected package gettext.
Preparing to unpack .../066-gettext_0.19.8.1-9_amd64.deb ...
Unpacking gettext (0.19.8.1-9) ...
Selecting previously unselected package intltool-debian.
Preparing to unpack .../067-intltool-debian_0.35.0+20060710.5_all.deb ...
Unpacking intltool-debian (0.35.0+20060710.5) ...
Selecting previously unselected package po-debconf.
Preparing to unpack .../068-po-debconf_1.0.21_all.deb ...
Unpacking po-debconf (1.0.21) ...
Selecting previously unselected package debhelper.
Preparing to unpack .../069-debhelper_12.1.1_all.deb ...
Unpacking debhelper (12.1.1) ...
Selecting previously unselected package diffstat.
Preparing to unpack .../070-diffstat_1.62-1_amd64.deb ...
Unpacking diffstat (1.62-1) ...
Selecting previously unselected package gcc-8-base:armhf.
Preparing to unpack .../071-gcc-8-base_8.3.0-7_armhf.deb ...
Unpacking gcc-8-base:armhf (8.3.0-7) ...
Selecting previously unselected package libgeoip1:amd64.
Preparing to unpack .../072-libgeoip1_1.6.12-1_amd64.deb ...
Unpacking libgeoip1:amd64 (1.6.12-1) ...
Selecting previously unselected package geoip-bin.
Preparing to unpack .../073-geoip-bin_1.6.12-1_amd64.deb ...
Unpacking geoip-bin (1.6.12-1) ...
Selecting previously unselected package libgcc1:armhf.
Preparing to unpack .../074-libgcc1_1%3a8.3.0-7_armhf.deb ...
Unpacking libgcc1:armhf (1:8.3.0-7) ...
Selecting previously unselected package libc6:armhf.
Preparing to unpack .../075-libc6_2.28-10_armhf.deb ...
Unpacking libc6:armhf (2.28-10) ...
Selecting previously unselected package libstdc++6:armhf.
Preparing to unpack .../076-libstdc++6_8.3.0-7_armhf.deb ...
Unpacking libstdc++6:armhf (8.3.0-7) ...
Selecting previously unselected package libasan5:armhf.
Preparing to unpack .../077-libasan5_8.3.0-7_armhf.deb ...
Unpacking libasan5:armhf (8.3.0-7) ...
Selecting previously unselected package libatomic1:armhf.
Preparing to unpack .../078-libatomic1_8.3.0-7_armhf.deb ...
Unpacking libatomic1:armhf (8.3.0-7) ...
Selecting previously unselected package libcap2:armhf.
Preparing to unpack .../079-libcap2_1%3a2.25-2_armhf.deb ...
Unpacking libcap2:armhf (1:2.25-2) ...
Selecting previously unselected package libfstrm0:armhf.
Preparing to unpack .../080-libfstrm0_0.4.0-1_armhf.deb ...
Unpacking libfstrm0:armhf (0.4.0-1) ...
Selecting previously unselected package libgeoip1:armhf.
Preparing to unpack .../081-libgeoip1_1.6.12-1_armhf.deb ...
Unpacking libgeoip1:armhf (1.6.12-1) ...
Selecting previously unselected package libjson-c3:armhf.
Preparing to unpack .../082-libjson-c3_0.12.1+ds-2_armhf.deb ...
Unpacking libjson-c3:armhf (0.12.1+ds-2) ...
Selecting previously unselected package liblmdb0:armhf.
Preparing to unpack .../083-liblmdb0_0.9.22-1_armhf.deb ...
Unpacking liblmdb0:armhf (0.9.22-1) ...
Selecting previously unselected package libprotobuf-c1:armhf.
Preparing to unpack .../084-libprotobuf-c1_1.3.1-1+b1_armhf.deb ...
Unpacking libprotobuf-c1:armhf (1.3.1-1+b1) ...
Selecting previously unselected package libssl1.1:armhf.
Preparing to unpack .../085-libssl1.1_1.1.1c-1_armhf.deb ...
Unpacking libssl1.1:armhf (1.1.1c-1) ...
Selecting previously unselected package libicu63:armhf.
Preparing to unpack .../086-libicu63_63.2-2_armhf.deb ...
Unpacking libicu63:armhf (63.2-2) ...
Selecting previously unselected package liblzma5:armhf.
Preparing to unpack .../087-liblzma5_5.2.4-1_armhf.deb ...
Unpacking liblzma5:armhf (5.2.4-1) ...
Selecting previously unselected package zlib1g:armhf.
Preparing to unpack .../088-zlib1g_1%3a1.2.11.dfsg-1_armhf.deb ...
Unpacking zlib1g:armhf (1:1.2.11.dfsg-1) ...
Selecting previously unselected package libxml2:armhf.
Preparing to unpack .../089-libxml2_2.9.4+dfsg1-7+b3_armhf.deb ...
Unpacking libxml2:armhf (2.9.4+dfsg1-7+b3) ...
Selecting previously unselected package libisc1100:armhf.
Preparing to unpack .../090-libisc1100_1%3a9.11.5.P4+dfsg-5.1_armhf.deb ...
Unpacking libisc1100:armhf (1:9.11.5.P4+dfsg-5.1) ...
Selecting previously unselected package libcom-err2:armhf.
Preparing to unpack .../091-libcom-err2_1.45.2-1_armhf.deb ...
Unpacking libcom-err2:armhf (1.45.2-1) ...
Selecting previously unselected package libkeyutils1:armhf.
Preparing to unpack .../092-libkeyutils1_1.6-6_armhf.deb ...
Unpacking libkeyutils1:armhf (1.6-6) ...
Selecting previously unselected package libkrb5support0:armhf.
Preparing to unpack .../093-libkrb5support0_1.17-3_armhf.deb ...
Unpacking libkrb5support0:armhf (1.17-3) ...
Selecting previously unselected package libk5crypto3:armhf.
Preparing to unpack .../094-libk5crypto3_1.17-3_armhf.deb ...
Unpacking libk5crypto3:armhf (1.17-3) ...
Selecting previously unselected package libkrb5-3:armhf.
Preparing to unpack .../095-libkrb5-3_1.17-3_armhf.deb ...
Unpacking libkrb5-3:armhf (1.17-3) ...
Selecting previously unselected package libgssapi-krb5-2:armhf.
Preparing to unpack .../096-libgssapi-krb5-2_1.17-3_armhf.deb ...
Unpacking libgssapi-krb5-2:armhf (1.17-3) ...
Selecting previously unselected package libdns1104:armhf.
Preparing to unpack .../097-libdns1104_1%3a9.11.5.P4+dfsg-5.1_armhf.deb ...
Unpacking libdns1104:armhf (1:9.11.5.P4+dfsg-5.1) ...
Selecting previously unselected package libisccc161:armhf.
Preparing to unpack .../098-libisccc161_1%3a9.11.5.P4+dfsg-5.1_armhf.deb ...
Unpacking libisccc161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Selecting previously unselected package libisccfg163:armhf.
Preparing to unpack .../099-libisccfg163_1%3a9.11.5.P4+dfsg-5.1_armhf.deb ...
Unpacking libisccfg163:armhf (1:9.11.5.P4+dfsg-5.1) ...
Selecting previously unselected package libbind9-161:armhf.
Preparing to unpack .../100-libbind9-161_1%3a9.11.5.P4+dfsg-5.1_armhf.deb ...
Unpacking libbind9-161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Selecting previously unselected package libirs161:armhf.
Preparing to unpack .../101-libirs161_1%3a9.11.5.P4+dfsg-5.1_armhf.deb ...
Unpacking libirs161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Selecting previously unselected package liblwres161:armhf.
Preparing to unpack .../102-liblwres161_1%3a9.11.5.P4+dfsg-5.1_armhf.deb ...
Unpacking liblwres161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Selecting previously unselected package libbind-dev:armhf.
Preparing to unpack .../103-libbind-dev_1%3a9.11.5.P4+dfsg-5.1_armhf.deb ...
Unpacking libbind-dev:armhf (1:9.11.5.P4+dfsg-5.1) ...
Selecting previously unselected package libbsd0:armhf.
Preparing to unpack .../104-libbsd0_0.9.1-2_armhf.deb ...
Unpacking libbsd0:armhf (0.9.1-2) ...
Selecting previously unselected package linux-libc-dev:armhf.
Preparing to unpack .../105-linux-libc-dev_4.19.37-5_armhf.deb ...
Unpacking linux-libc-dev:armhf (4.19.37-5) ...
Selecting previously unselected package libc6-dev:armhf.
Preparing to unpack .../106-libc6-dev_2.28-10_armhf.deb ...
Unpacking libc6-dev:armhf (2.28-10) ...
Selecting previously unselected package libunistring2:armhf.
Preparing to unpack .../107-libunistring2_0.9.10-1_armhf.deb ...
Unpacking libunistring2:armhf (0.9.10-1) ...
Selecting previously unselected package libidn2-0:armhf.
Preparing to unpack .../108-libidn2-0_2.0.5-1_armhf.deb ...
Unpacking libidn2-0:armhf (2.0.5-1) ...
Selecting previously unselected package libgmp10:armhf.
Preparing to unpack .../109-libgmp10_2%3a6.1.2+dfsg-4_armhf.deb ...
Unpacking libgmp10:armhf (2:6.1.2+dfsg-4) ...
Selecting previously unselected package libnettle6:armhf.
Preparing to unpack .../110-libnettle6_3.4.1-1_armhf.deb ...
Unpacking libnettle6:armhf (3.4.1-1) ...
Selecting previously unselected package libhogweed4:armhf.
Preparing to unpack .../111-libhogweed4_3.4.1-1_armhf.deb ...
Unpacking libhogweed4:armhf (3.4.1-1) ...
Selecting previously unselected package libffi6:armhf.
Preparing to unpack .../112-libffi6_3.2.1-9_armhf.deb ...
Unpacking libffi6:armhf (3.2.1-9) ...
Selecting previously unselected package libp11-kit0:armhf.
Preparing to unpack .../113-libp11-kit0_0.23.15-2_armhf.deb ...
Unpacking libp11-kit0:armhf (0.23.15-2) ...
Selecting previously unselected package libtasn1-6:armhf.
Preparing to unpack .../114-libtasn1-6_4.13-3_armhf.deb ...
Unpacking libtasn1-6:armhf (4.13-3) ...
Selecting previously unselected package libgnutls30:armhf.
Preparing to unpack .../115-libgnutls30_3.6.7-4_armhf.deb ...
Unpacking libgnutls30:armhf (3.6.7-4) ...
Selecting previously unselected package libdb5.3:armhf.
Preparing to unpack .../116-libdb5.3_5.3.28+dfsg1-0.6_armhf.deb ...
Unpacking libdb5.3:armhf (5.3.28+dfsg1-0.6) ...
Selecting previously unselected package libsasl2-modules-db:armhf.
Preparing to unpack .../117-libsasl2-modules-db_2.1.27+dfsg-1_armhf.deb ...
Unpacking libsasl2-modules-db:armhf (2.1.27+dfsg-1) ...
Selecting previously unselected package libsasl2-2:armhf.
Preparing to unpack .../118-libsasl2-2_2.1.27+dfsg-1_armhf.deb ...
Unpacking libsasl2-2:armhf (2.1.27+dfsg-1) ...
Selecting previously unselected package libldap-2.4-2:armhf.
Preparing to unpack .../119-libldap-2.4-2_2.4.47+dfsg-3_armhf.deb ...
Unpacking libldap-2.4-2:armhf (2.4.47+dfsg-3) ...
Selecting previously unselected package libnghttp2-14:armhf.
Preparing to unpack .../120-libnghttp2-14_1.37.0-1_armhf.deb ...
Unpacking libnghttp2-14:armhf (1.37.0-1) ...
Selecting previously unselected package libpsl5:armhf.
Preparing to unpack .../121-libpsl5_0.20.2-2_armhf.deb ...
Unpacking libpsl5:armhf (0.20.2-2) ...
Selecting previously unselected package librtmp1:armhf.
Preparing to unpack .../122-librtmp1_2.4+20151223.gitfa8646d.1-2_armhf.deb ...
Unpacking librtmp1:armhf (2.4+20151223.gitfa8646d.1-2) ...
Selecting previously unselected package libgpg-error0:armhf.
Preparing to unpack .../123-libgpg-error0_1.35-1_armhf.deb ...
Unpacking libgpg-error0:armhf (1.35-1) ...
Selecting previously unselected package libgcrypt20:armhf.
Preparing to unpack .../124-libgcrypt20_1.8.4-5_armhf.deb ...
Unpacking libgcrypt20:armhf (1.8.4-5) ...
Selecting previously unselected package libssh2-1:armhf.
Preparing to unpack .../125-libssh2-1_1.8.0-2.1_armhf.deb ...
Unpacking libssh2-1:armhf (1.8.0-2.1) ...
Selecting previously unselected package libcurl4:armhf.
Preparing to unpack .../126-libcurl4_7.64.0-4_armhf.deb ...
Unpacking libcurl4:armhf (7.64.0-4) ...
Selecting previously unselected package libcurl4-openssl-dev:armhf.
Preparing to unpack .../127-libcurl4-openssl-dev_7.64.0-4_armhf.deb ...
Unpacking libcurl4-openssl-dev:armhf (7.64.0-4) ...
Selecting previously unselected package libgomp1:armhf.
Preparing to unpack .../128-libgomp1_8.3.0-7_armhf.deb ...
Unpacking libgomp1:armhf (8.3.0-7) ...
Selecting previously unselected package libubsan1:armhf.
Preparing to unpack .../129-libubsan1_8.3.0-7_armhf.deb ...
Unpacking libubsan1:armhf (8.3.0-7) ...
Selecting previously unselected package libgcc-8-dev:armhf.
Preparing to unpack .../130-libgcc-8-dev_8.3.0-7_armhf.deb ...
Unpacking libgcc-8-dev:armhf (8.3.0-7) ...
Selecting previously unselected package libgeoip-dev:armhf.
Preparing to unpack .../131-libgeoip-dev_1.6.12-1_armhf.deb ...
Unpacking libgeoip-dev:armhf (1.6.12-1) ...
Selecting previously unselected package libmilter1.0.1:armhf.
Preparing to unpack .../132-libmilter1.0.1_8.15.2-12_armhf.deb ...
Unpacking libmilter1.0.1:armhf (8.15.2-12) ...
Selecting previously unselected package libmilter-dev:armhf.
Preparing to unpack .../133-libmilter-dev_8.15.2-12_armhf.deb ...
Unpacking libmilter-dev:armhf (8.15.2-12) ...
Selecting previously unselected package libopendkim11:armhf.
Preparing to unpack .../134-libopendkim11_2.11.0~alpha-12_armhf.deb ...
Unpacking libopendkim11:armhf (2.11.0~alpha-12) ...
Selecting previously unselected package libopendkim-dev:armhf.
Preparing to unpack .../135-libopendkim-dev_2.11.0~alpha-12_armhf.deb ...
Unpacking libopendkim-dev:armhf (2.11.0~alpha-12) ...
Selecting previously unselected package libspf2-2:armhf.
Preparing to unpack .../136-libspf2-2_1.2.10-7+b5_armhf.deb ...
Unpacking libspf2-2:armhf (1.2.10-7+b5) ...
Selecting previously unselected package libspf2-dev:armhf.
Preparing to unpack .../137-libspf2-dev_1.2.10-7+b5_armhf.deb ...
Unpacking libspf2-dev:armhf (1.2.10-7+b5) ...
Selecting previously unselected package libssl-dev:armhf.
Preparing to unpack .../138-libssl-dev_1.1.1c-1_armhf.deb ...
Unpacking libssl-dev:armhf (1.1.1c-1) ...
Selecting previously unselected package libstdc++-8-dev:armhf.
Preparing to unpack .../139-libstdc++-8-dev_8.3.0-7_armhf.deb ...
Unpacking libstdc++-8-dev:armhf (8.3.0-7) ...
Selecting previously unselected package quilt.
Preparing to unpack .../140-quilt_0.65-3_all.deb ...
Unpacking quilt (0.65-3) ...
Selecting previously unselected package sbuild-build-depends-main-dummy:armhf.
Preparing to unpack .../141-sbuild-build-depends-main-dummy_0.invalid.0_armhf.deb ...
Unpacking sbuild-build-depends-main-dummy:armhf (0.invalid.0) ...
Setting up libconfig-inifiles-perl (3.000001-1) ...
Setting up libpipeline1:amd64 (1.5.1-2) ...
Setting up libfile-which-perl (1.23-1) ...
Setting up libc6-armhf-cross (2.28-10cross2) ...
Setting up libmagic-mgc (1:5.35-4) ...
Setting up libarchive-zip-perl (1.64-1) ...
Setting up libglib2.0-0:amd64 (2.58.3-2) ...
No schema files found: doing nothing.
Setting up gcc-8-cross-base (8.3.0-7cross1) ...
Setting up libmagic1:amd64 (1:5.35-4) ...
Setting up linux-libc-dev:armhf (4.19.37-5) ...
Setting up libxml-namespacesupport-perl (1.12-1) ...
Setting up gettext-base (0.19.8.1-9) ...
Setting up file (1:5.35-4) ...
Setting up libatomic1-armhf-cross (8.3.0-7cross1) ...
Setting up libyaml-perl (1.27-1) ...
Setting up libicu63:amd64 (63.2-2) ...
Setting up libxml-sax-base-perl (1.09-1) ...
Setting up libio-string-perl (1.08-3) ...
Setting up autotools-dev (20180224.1) ...
Setting up cross-config (2.6.15-3) ...
Setting up libgcc1-armhf-cross (1:8.3.0-7cross1) ...
Setting up gcc-8-arm-linux-gnueabihf-base:amd64 (8.3.0-7cross1) ...
Setting up libncurses6:amd64 (6.1+20181013-2) ...
Setting up libsigsegv2:amd64 (2.12-2) ...
Setting up diffstat (1.62-1) ...
Setting up gcc-8-base:armhf (8.3.0-7) ...
Setting up linux-libc-dev-armhf-cross (4.19.28-2cross2) ...
Setting up autopoint (0.19.8.1-9) ...
Setting up ucf (3.0038+nmu1) ...
Setting up dwz (0.12-3) ...
Setting up libuchardet0:amd64 (0.0.6-3) ...
Setting up libgeoip1:amd64 (1.6.12-1) ...
Setting up libfile-homedir-perl (1.004-1) ...
Setting up libbsd0:amd64 (0.9.1-2) ...
Setting up binutils-arm-linux-gnueabihf (2.31.1-16) ...
Setting up libxml2:amd64 (2.9.4+dfsg1-7+b3) ...
Setting up liblocale-gettext-perl (1.07-3+b4) ...
Setting up cpp-8-arm-linux-gnueabihf (8.3.0-7cross1) ...
Setting up libgomp1-armhf-cross (8.3.0-7cross1) ...
Setting up libfile-stripnondeterminism-perl (1.1.2-1) ...
Setting up libtool (2.4.6-10) ...
Setting up geoip-bin (1.6.12-1) ...
Setting up libc6-dev-armhf-cross (2.28-10cross2) ...
Setting up m4 (1.4.18-2) ...
Setting up libxml-sax-perl (1.00+dfsg-1) ...
update-perl-sax-parsers: Registering Perl SAX parser XML::SAX::PurePerl with priority 10...
update-perl-sax-parsers: Updating overall Perl SAX parser modules info file...

Creating config file /etc/perl/XML/SAX/ParserDetails.ini with new version
Setting up libstdc++6-armhf-cross (8.3.0-7cross1) ...
Setting up bsdmainutils (11.1.2+b1) ...
update-alternatives: using /usr/bin/bsd-write to provide /usr/bin/write (write) in auto mode
update-alternatives: using /usr/bin/bsd-from to provide /usr/bin/from (from) in auto mode
Setting up libcroco3:amd64 (0.6.12-3) ...
Setting up libubsan1-armhf-cross (8.3.0-7cross1) ...
Setting up autoconf (2.69-11) ...
Setting up libxml-libxml-perl (2.0134+dfsg-1) ...
update-perl-sax-parsers: Registering Perl SAX parser XML::LibXML::SAX::Parser with priority 50...
update-perl-sax-parsers: Registering Perl SAX parser XML::LibXML::SAX with priority 50...
update-perl-sax-parsers: Updating overall Perl SAX parser modules info file...
Replacing config file /etc/perl/XML/SAX/ParserDetails.ini with new version
Setting up groff-base (1.22.4-3) ...
Setting up bison (2:3.4.1+dfsg-2) ...
update-alternatives: using /usr/bin/bison.yacc to provide /usr/bin/yacc (yacc) in auto mode
Setting up cpp-arm-linux-gnueabihf (4:8.3.0-1) ...
Setting up automake (1:1.16.1-4) ...
update-alternatives: using /usr/bin/automake-1.16 to provide /usr/bin/automake (automake) in auto mode
Setting up flex (2.6.4-6.2) ...
Setting up gettext (0.19.8.1-9) ...
Setting up quilt (0.65-3) ...
Setting up man-db (2.8.5-2) ...
Not building database; man-db/auto-update is not 'true'.
Setting up libasan5-armhf-cross (8.3.0-7cross1) ...
Setting up intltool-debian (0.35.0+20060710.5) ...
Setting up libxml-simple-perl (2.25-1) ...
Setting up libgcc-8-dev-armhf-cross (8.3.0-7cross1) ...
Setting up libstdc++-8-dev-armhf-cross (8.3.0-7cross1) ...
Setting up gcc-8-arm-linux-gnueabihf (8.3.0-7cross1) ...
Setting up gcc-arm-linux-gnueabihf (4:8.3.0-1) ...
Setting up po-debconf (1.0.21) ...
Setting up libconfig-auto-perl (0.44-1) ...
Setting up g++-8-arm-linux-gnueabihf (8.3.0-7cross1) ...
Setting up libdebian-dpkgcross-perl (2.6.15-3) ...
Setting up g++-arm-linux-gnueabihf (4:8.3.0-1) ...
Setting up dpkg-cross (2.6.15-3) ...
Setting up crossbuild-essential-armhf (12.6) ...
Setting up libc6:armhf (2.28-10) ...
Setting up libgeoip1:armhf (1.6.12-1) ...
Setting up libtasn1-6:armhf (4.13-3) ...
Setting up libc6-dev:armhf (2.28-10) ...
Setting up libspf2-2:armhf (1.2.10-7+b5) ...
Setting up libbsd0:armhf (0.9.1-2) ...
Setting up libdb5.3:armhf (5.3.28+dfsg1-0.6) ...
Setting up liblmdb0:armhf (0.9.22-1) ...
Setting up libjson-c3:armhf (0.12.1+ds-2) ...
Setting up libkeyutils1:armhf (1.6-6) ...
Setting up libgeoip-dev:armhf (1.6.12-1) ...
Setting up liblzma5:armhf (5.2.4-1) ...
Setting up libgpg-error0:armhf (1.35-1) ...
Setting up libgcc1:armhf (1:8.3.0-7) ...
Setting up libssl1.1:armhf (1.1.1c-1) ...
Setting up libfstrm0:armhf (0.4.0-1) ...
Setting up libnghttp2-14:armhf (1.37.0-1) ...
Setting up libunistring2:armhf (0.9.10-1) ...
Setting up libgcrypt20:armhf (1.8.4-5) ...
Setting up debhelper (12.1.1) ...
Setting up zlib1g:armhf (1:1.2.11.dfsg-1) ...
Setting up libffi6:armhf (3.2.1-9) ...
Setting up libidn2-0:armhf (2.0.5-1) ...
Setting up libcom-err2:armhf (1.45.2-1) ...
Setting up libgomp1:armhf (8.3.0-7) ...
Setting up libprotobuf-c1:armhf (1.3.1-1+b1) ...
Setting up libcap2:armhf (1:2.25-2) ...
Setting up libkrb5support0:armhf (1.17-3) ...
Setting up libopendkim11:armhf (2.11.0~alpha-12) ...
Setting up libsasl2-modules-db:armhf (2.1.27+dfsg-1) ...
Setting up dh-autoreconf (19) ...
Setting up libmilter1.0.1:armhf (8.15.2-12) ...
Setting up libgmp10:armhf (2:6.1.2+dfsg-4) ...
Setting up libp11-kit0:armhf (0.23.15-2) ...
Setting up libssl-dev:armhf (1.1.1c-1) ...
Setting up libatomic1:armhf (8.3.0-7) ...
Setting up libk5crypto3:armhf (1.17-3) ...
Setting up libnettle6:armhf (3.4.1-1) ...
Setting up libsasl2-2:armhf (2.1.27+dfsg-1) ...
Setting up dh-strip-nondeterminism (1.1.2-1) ...
Setting up libssh2-1:armhf (1.8.0-2.1) ...
Setting up libspf2-dev:armhf (1.2.10-7+b5) ...
Setting up libkrb5-3:armhf (1.17-3) ...
Setting up libstdc++6:armhf (8.3.0-7) ...
Setting up libpsl5:armhf (0.20.2-2) ...
Setting up libhogweed4:armhf (3.4.1-1) ...
Setting up libmilter-dev:armhf (8.15.2-12) ...
Setting up libopendkim-dev:armhf (2.11.0~alpha-12) ...
Setting up libicu63:armhf (63.2-2) ...
Setting up libasan5:armhf (8.3.0-7) ...
Setting up libgnutls30:armhf (3.6.7-4) ...
Setting up librtmp1:armhf (2.4+20151223.gitfa8646d.1-2) ...
Setting up libgssapi-krb5-2:armhf (1.17-3) ...
Setting up libubsan1:armhf (8.3.0-7) ...
Setting up libxml2:armhf (2.9.4+dfsg1-7+b3) ...
Setting up libldap-2.4-2:armhf (2.4.47+dfsg-3) ...
Setting up libisc1100:armhf (1:9.11.5.P4+dfsg-5.1) ...
Setting up liblwres161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Setting up libgcc-8-dev:armhf (8.3.0-7) ...
Setting up libcurl4:armhf (7.64.0-4) ...
Setting up libisccc161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Setting up libstdc++-8-dev:armhf (8.3.0-7) ...
Setting up libdns1104:armhf (1:9.11.5.P4+dfsg-5.1) ...
Setting up libcurl4-openssl-dev:armhf (7.64.0-4) ...
Setting up libisccfg163:armhf (1:9.11.5.P4+dfsg-5.1) ...
Setting up libbind9-161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Setting up libirs161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Setting up libbind-dev:armhf (1:9.11.5.P4+dfsg-5.1) ...
Setting up sbuild-build-depends-main-dummy:armhf (0.invalid.0) ...
Processing triggers for libc-bin (2.28-10) ...
Processing triggers for ccache (3.7.1-1) ...
Updating symlinks in /usr/lib/ccache ...

+------------------------------------------------------------------------------+
| Check architectures                                                          |
+------------------------------------------------------------------------------+

Initial Foreign Architectures: armhf 
Arch check ok (armhf included in any)

+------------------------------------------------------------------------------+
| Build environment                                                            |
+------------------------------------------------------------------------------+

Kernel: Linux 3.16.0-4-amd64 #1 SMP Debian 3.16.51-3 (2017-12-13) amd64 (x86_64)
Toolchain package versions: binutils_2.31.1-16 dpkg-dev_1.19.7 g++-8_8.3.0-7 gcc-8_8.3.0-7 libc6-dev_2.28-10 libstdc++-8-dev_8.3.0-7 libstdc++-8-dev-armhf-cross_8.3.0-7cross1 libstdc++6_8.3.0-7 libstdc++6-armhf-cross_8.3.0-7cross1 linux-libc-dev_4.19.37-5
Package versions: adduser_3.118 apt_1.8.2 autoconf_2.69-11 automake_1:1.16.1-4 autopoint_0.19.8.1-9 autotools-dev_20180224.1 base-files_10.3 base-passwd_3.5.46 bash_5.0-4 binutils_2.31.1-16 binutils-arm-linux-gnueabihf_2.31.1-16 binutils-common_2.31.1-16 binutils-x86-64-linux-gnu_2.31.1-16 bison_2:3.4.1+dfsg-2 bsdmainutils_11.1.2+b1 bsdutils_1:2.33.1-0.1 build-essential_12.6 bzip2_1.0.6-9.1 ccache_3.7.1-1 coreutils_8.30-3 cpp_4:8.3.0-1 cpp-8_8.3.0-7 cpp-8-arm-linux-gnueabihf_8.3.0-7cross1 cpp-arm-linux-gnueabihf_4:8.3.0-1 cross-config_2.6.15-3 crossbuild-essential-armhf_12.6 dash_0.5.10.2-5 debconf_1.5.72 debhelper_12.1.1 debian-archive-keyring_2019.1 debianutils_4.8.6.1 dh-autoreconf_19 dh-strip-nondeterminism_1.1.2-1 diffstat_1.62-1 diffutils_1:3.7-3 dirmngr_2.2.13-2 dose-distcheck_5.0.1-12 dpkg_1.19.7 dpkg-cross_2.6.15-3 dpkg-dev_1.19.7 dwz_0.12-3 e2fsprogs_1.45.2-1 eatmydata_105-7 fakeroot_1.23-1 fdisk_2.33.1-0.1 file_1:5.35-4 findutils_4.6.0+git+20190209-2 flex_2.6.4-6.2 g++_4:8.3.0-1 g++-8_8.3.0-7 g++-8-arm-linux-gnueabihf_8.3.0-7cross1 g++-arm-linux-gnueabihf_4:8.3.0-1 gcc_4:8.3.0-1 gcc-8_8.3.0-7 gcc-8-arm-linux-gnueabihf_8.3.0-7cross1 gcc-8-arm-linux-gnueabihf-base_8.3.0-7cross1 gcc-8-base_8.3.0-7 gcc-8-cross-base_8.3.0-7cross1 gcc-arm-linux-gnueabihf_4:8.3.0-1 geoip-bin_1.6.12-1 gettext_0.19.8.1-9 gettext-base_0.19.8.1-9 gnupg_2.2.13-2 gnupg-l10n_2.2.13-2 gnupg-utils_2.2.13-2 gpg_2.2.13-2 gpg-agent_2.2.13-2 gpg-wks-client_2.2.13-2 gpg-wks-server_2.2.13-2 gpgconf_2.2.13-2 gpgsm_2.2.13-2 gpgv_2.2.13-2 grep_3.3-1 groff-base_1.22.4-3 gzip_1.9-3 hostname_3.21 init-system-helpers_1.57 intltool-debian_0.35.0+20060710.5 libacl1_2.2.53-4 libapt-pkg5.0_1.8.2 libarchive-zip-perl_1.64-1 libasan5_8.3.0-7 libasan5-armhf-cross_8.3.0-7cross1 libassuan0_2.5.2-1 libatomic1_8.3.0-7 libatomic1-armhf-cross_8.3.0-7cross1 libattr1_1:2.4.48-4 libaudit-common_1:2.8.4-3 libaudit1_1:2.8.4-3 libbind-dev_1:9.11.5.P4+dfsg-5.1 libbind9-161_1:9.11.5.P4+dfsg-5.1 libbinutils_2.31.1-16 libblkid1_2.33.1-0.1 libbsd0_0.9.1-2 libbz2-1.0_1.0.6-9.1 libc-bin_2.28-10 libc-dev-bin_2.28-10 libc6_2.28-10 libc6-armhf-cross_2.28-10cross2 libc6-dev_2.28-10 libc6-dev-armhf-cross_2.28-10cross2 libcap-ng0_0.7.9-2 libcap2_1:2.25-2 libcc1-0_8.3.0-7 libcom-err2_1.45.2-1 libconfig-auto-perl_0.44-1 libconfig-inifiles-perl_3.000001-1 libcroco3_0.6.12-3 libcurl4_7.64.0-4 libcurl4-openssl-dev_7.64.0-4 libdb5.3_5.3.28+dfsg1-0.6 libdebconfclient0_0.249 libdebian-dpkgcross-perl_2.6.15-3 libdns1104_1:9.11.5.P4+dfsg-5.1 libdpkg-perl_1.19.7 libeatmydata1_105-7 libelf1_0.176-1.1 libext2fs2_1.45.2-1 libfakeroot_1.23-1 libfdisk1_2.33.1-0.1 libffi6_3.2.1-9 libfile-homedir-perl_1.004-1 libfile-stripnondeterminism-perl_1.1.2-1 libfile-which-perl_1.23-1 libfstrm0_0.4.0-1 libgcc-8-dev_8.3.0-7 libgcc-8-dev-armhf-cross_8.3.0-7cross1 libgcc1_1:8.3.0-7 libgcc1-armhf-cross_1:8.3.0-7cross1 libgcrypt20_1.8.4-5 libgdbm-compat4_1.18.1-4 libgdbm6_1.18.1-4 libgeoip-dev_1.6.12-1 libgeoip1_1.6.12-1 libglib2.0-0_2.58.3-2 libgmp10_2:6.1.2+dfsg-4 libgnutls30_3.6.7-4 libgomp1_8.3.0-7 libgomp1-armhf-cross_8.3.0-7cross1 libgpg-error0_1.35-1 libgssapi-krb5-2_1.17-3 libhogweed4_3.4.1-1 libicu63_63.2-2 libidn2-0_2.0.5-1 libio-string-perl_1.08-3 libirs161_1:9.11.5.P4+dfsg-5.1 libisc1100_1:9.11.5.P4+dfsg-5.1 libisccc161_1:9.11.5.P4+dfsg-5.1 libisccfg163_1:9.11.5.P4+dfsg-5.1 libisl19_0.20-2 libitm1_8.3.0-7 libjson-c3_0.12.1+ds-2 libk5crypto3_1.17-3 libkeyutils1_1.6-6 libkrb5-3_1.17-3 libkrb5support0_1.17-3 libksba8_1.3.5-2 libldap-2.4-2_2.4.47+dfsg-3 libldap-common_2.4.47+dfsg-3 liblmdb0_0.9.22-1 liblocale-gettext-perl_1.07-3+b4 liblsan0_8.3.0-7 liblua5.2-0_5.2.4-1.1+b2 liblwres161_1:9.11.5.P4+dfsg-5.1 liblz4-1_1.8.3-1 liblzma5_5.2.4-1 libmagic-mgc_1:5.35-4 libmagic1_1:5.35-4 libmilter-dev_8.15.2-12 libmilter1.0.1_8.15.2-12 libmount1_2.33.1-0.1 libmpc3_1.1.0-1 libmpfr6_4.0.2-1 libmpx2_8.3.0-7 libncurses6_6.1+20181013-2 libncursesw6_6.1+20181013-2 libnettle6_3.4.1-1 libnghttp2-14_1.37.0-1 libnpth0_1.6-1 libnspr4_2:4.21-1 libnss3_2:3.44+really3.42.1-2 libopendkim-dev_2.11.0~alpha-12 libopendkim11_2.11.0~alpha-12 libp11-kit0_0.23.15-2 libpam-modules_1.3.1-5 libpam-modules-bin_1.3.1-5 libpam-runtime_1.3.1-5 libpam0g_1.3.1-5 libpcre3_2:8.39-12 libperl5.28_5.28.1-6 libpipeline1_1.5.1-2 libpopt0_1.16-12 libprotobuf-c1_1.3.1-1+b1 libpsl5_0.20.2-2 libquadmath0_8.3.0-7 libreadline7_7.0-5 librpm8_4.14.2.1+dfsg1-1 librpmio8_4.14.2.1+dfsg1-1 librtmp1_2.4+20151223.gitfa8646d.1-2 libsasl2-2_2.1.27+dfsg-1 libsasl2-modules-db_2.1.27+dfsg-1 libseccomp2_2.3.3-4 libselinux1_2.8-1+b1 libsemanage-common_2.8-2 libsemanage1_2.8-2 libsepol1_2.8-1 libsigsegv2_2.12-2 libsmartcols1_2.33.1-0.1 libspf2-2_1.2.10-7+b5 libspf2-dev_1.2.10-7+b5 libsqlite3-0_3.27.2-3 libss2_1.45.2-1 libssh2-1_1.8.0-2.1 libssl-dev_1.1.1c-1 libssl1.1_1.1.1c-1 libstdc++-8-dev_8.3.0-7 libstdc++-8-dev-armhf-cross_8.3.0-7cross1 libstdc++6_8.3.0-7 libstdc++6-armhf-cross_8.3.0-7cross1 libsystemd0_241-5 libtasn1-6_4.13-3 libtinfo6_6.1+20181013-2 libtool_2.4.6-10 libtsan0_8.3.0-7 libubsan1_8.3.0-7 libubsan1-armhf-cross_8.3.0-7cross1 libuchardet0_0.0.6-3 libudev1_241-5 libunistring2_0.9.10-1 libuuid1_2.33.1-0.1 libxml-libxml-perl_2.0134+dfsg-1 libxml-namespacesupport-perl_1.12-1 libxml-sax-base-perl_1.09-1 libxml-sax-perl_1.00+dfsg-1 libxml-simple-perl_2.25-1 libxml2_2.9.4+dfsg1-7+b3 libyaml-perl_1.27-1 libzstd1_1.3.8+dfsg-3 linux-libc-dev_4.19.37-5 linux-libc-dev-armhf-cross_4.19.28-2cross2 login_1:4.5-1.1 lsb-base_10.2019051400 m4_1.4.18-2 make_4.2.1-1.2 man-db_2.8.5-2 mawk_1.3.3-17+b3 mount_2.33.1-0.1 ncurses-base_6.1+20181013-2 ncurses-bin_6.1+20181013-2 passwd_1:4.5-1.1 patch_2.7.6-4 perl_5.28.1-6 perl-base_5.28.1-6 perl-modules-5.28_5.28.1-6 pinentry-curses_1.1.0-2 po-debconf_1.0.21 quilt_0.65-3 readline-common_7.0-5 sbuild-build-depends-dose3-dummy_0.invalid.0 sbuild-build-depends-main-dummy_0.invalid.0 sed_4.7-1 sensible-utils_0.0.12 sysvinit-utils_2.93-8 tar_1.30+dfsg-6 tzdata_2019a-1 ucf_3.0038+nmu1 util-linux_2.33.1-0.1 xz-utils_5.2.4-1 zlib1g_1:1.2.11.dfsg-1

+------------------------------------------------------------------------------+
| Build                                                                        |
+------------------------------------------------------------------------------+


Unpack source
-------------

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: milter-greylist
Binary: milter-greylist
Architecture: any
Version: 4.5.11-1.1
Maintainer: Paul Martin <pm@debian.org>
Standards-Version: 3.9.5
Build-Depends: quilt, debhelper (>= 9), autotools-dev, libmilter-dev, bison, flex, libspf2-dev, libcurl4-openssl-dev, libopendkim-dev, libssl-dev, libgeoip-dev, libbind-dev
Package-List:
 milter-greylist deb mail extra arch=any
Checksums-Sha1:
 c8dd62be53e8a8b4c75fa42774d72ac0345479f8 254586 milter-greylist_4.5.11.orig.tar.gz
 4856e2d6d84800deb9e31eed5597187be4036a86 11408 milter-greylist_4.5.11-1.1.debian.tar.xz
Checksums-Sha256:
 e412d189e936924ea6b4b8b24262f027a7c9c73cff3fe6ed7c0c09dfcfac1595 254586 milter-greylist_4.5.11.orig.tar.gz
 f26b95279bda01bd0a3858b35937ea9deba39eb220aac50dd815155cb033f943 11408 milter-greylist_4.5.11-1.1.debian.tar.xz
Files:
 d819c17be4ea9ffc9db62f1d619aec49 254586 milter-greylist_4.5.11.orig.tar.gz
 38634b545df4a4e9d4db726e99550294 11408 milter-greylist_4.5.11-1.1.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQIcBAEBCAAGBQJYE8CXAAoJEHjX3vua1ZrxCGIQAKFyKbprp/oYgqdiCFYFqPYJ
g3UEP94usWphioeLvDj/qkp0CezJ8RIV+ff5pmGbl1tvfvMsAjtkOk/9RXHTwR8H
rfswMyCqfHaklo4j6vyMwIidm7IjlqdU9bP/oq5s2A1g6IJRy5HHvCoB+YPvLemJ
HOTm9BJ6WkdO26Sq5DTgErXKxF2VjLdRfhJ1P6oc/gElyBA9MuXYP7vRFmj0Yzk9
pmmCSXmgUKwBT8+t0X0gClG0Jm7KeXTbpi44+i09XSdzg9f82t6IUaMNmGrteXSG
IDRZmYQahQax8tF58gzJHlxhD5PgzQCV//xYBc6Y9U4VpMZFQGNEolZKSegVMPk0
UqXLlhsmFnNMBH51MWwCOp0fpu+saTH8Khc0yrGjWe3WfHOU4fObwj67+Uc8/6EB
FxnvSx3Z43DgvSN4FvPbqzmM+a1td4jf6l1LPrKThIBP4ZgL2CRQRpYIX8t5QiaJ
tAlRheUY2ISl2KYrUlngkkOFQpuHXyMJKgDkT6X7IBOu3N++qK2F9wlnE7KMyJ2P
FeEj4QT1v6hBttFOa0tqPYduC8mdenc9M5eia7gws3jR2u9lvsfmvkSaMVHt4dOs
j4ekxy/H7bObrjWP/hWaqD/r0OA+wszVXUcLCjkr3JbjYcfV0T1FVzjQSjT676D3
4lNnThSak8h7i3Mj3G5J
=rLO0
-----END PGP SIGNATURE-----

gpgv: unknown type of key resource 'trustedkeys.kbx'
gpgv: keyblock resource '/sbuild-nonexistent/.gnupg/trustedkeys.kbx': General error
gpgv: Signature made Fri Oct 28 21:18:15 2016 UTC
gpgv:                using RSA key 78D7DEFB9AD59AF1
gpgv: Can't check signature: No public key
dpkg-source: warning: failed to verify signature on ./milter-greylist_4.5.11-1.1.dsc
dpkg-source: info: extracting milter-greylist in /<<PKGBUILDDIR>>
dpkg-source: info: unpacking milter-greylist_4.5.11.orig.tar.gz
dpkg-source: info: unpacking milter-greylist_4.5.11-1.1.debian.tar.xz
dpkg-source: info: using patch list from debian/patches/series
dpkg-source: info: applying m4.socket-options
dpkg-source: info: applying greylist.conf
dpkg-source: info: applying rc-debian.utf8
dpkg-source: info: applying rc-debian.socket
dpkg-source: info: applying conf-dumpfreq
dpkg-source: info: applying tempfs.508122
dpkg-source: info: applying initfile.mountall
dpkg-source: info: applying 573936-dump_lex
dpkg-source: info: applying initfile.lsb
dpkg-source: info: applying initfile.nosudo
dpkg-source: info: applying default_source.patch

Check disk space
----------------

Sufficient free space for build

User Environment
----------------

APT_CONFIG=/var/lib/sbuild/apt.conf
CCACHE_COMPRESS=1
CCACHE_DIR=/var/cache/ccache-sbuild
CCACHE_UMASK=002
CONFIG_SITE=/etc/dpkg-cross/cross-config.armhf
DEB_BUILD_OPTIONS=nocheck
HOME=/sbuild-nonexistent
LANG=en_US.UTF-8
LC_ALL=C.UTF-8
LD_LIBRARY_PATH=/usr/lib/libeatmydata
LD_PRELOAD=libeatmydata.so
LOGNAME=build
PATH=/usr/lib/ccache:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
PWD=/<<PKGBUILDDIR>>
SCHROOT_ALIAS_NAME=unstable-amd64-sbuild
SCHROOT_CHROOT_NAME=unstable-amd64-sbuild
SCHROOT_COMMAND=env
SCHROOT_GID=1000
SCHROOT_GROUP=build
SCHROOT_SESSION_ID=unstable-amd64-sbuild-aa5c1dd4-45f4-42ff-9efd-05222d3ce779
SCHROOT_UID=1000
SCHROOT_USER=build
SHELL=/bin/sh
USER=build

dpkg-buildpackage
-----------------

Command: dpkg-buildpackage -aarmhf -Pcross,nocheck -us -uc -B -rfakeroot -j16
dpkg-buildpackage: info: source package milter-greylist
dpkg-buildpackage: info: source version 4.5.11-1.1
dpkg-buildpackage: info: source distribution unstable
dpkg-buildpackage: info: source changed by Scott Kitterman <scott@kitterman.com>
dpkg-architecture: warning: specified GNU system type arm-linux-gnueabihf does not match CC system type x86_64-linux-gnu, try setting a correct CC environment variable
 dpkg-source --before-build .
dpkg-buildpackage: info: host architecture armhf
 fakeroot debian/rules clean
dh clean --with autotools_dev
dh: The autotools-dev sequence is deprecated and replaced by dh in debhelper (>= 9.20160115)
dh: This feature will be removed in compat 12.
   debian/rules override_dh_auto_clean
make[1]: Entering directory '/<<PKGBUILDDIR>>'
dh_auto_clean
	make -j1 distclean
make[2]: Entering directory '/<<PKGBUILDDIR>>'
rm -f milter-greylist milter-greylist.o pending.o sync.o dnsrbl.o list.o macro.o conf.o store.o dump.o spf.o acl.o urlcheck.o stat.o clock.o geoip.o fd_pool.o prop.o ldapcheck.o dkimcheck.o p0f.o spamd.o mx.o ratelimit.o nsupdate.o brokenmfapi.o conf_yacc.o dump_yacc.o .objseq-built conf_yacc.c conf_lex.c dump_yacc.c dump_lex.c \
	rc-redhat.sh rc-bsd.sh rc-solaris.sh rc-debian.sh rc-gentoo.sh \
	rc-suse.sh y.tab.c
sync || true
rm -Rf Makefile config.h config.log config.status \
	 autom4te.cache configure.lineno *.orig *.bak autoscan.log
sync || true
make[2]: Leaving directory '/<<PKGBUILDDIR>>'
rm -f debian/milter-greylist.init
# The following keeps lintian happy
rm -f milter-greylist.spec
# Sometimes autoconf doesn't clean up after itself
rm -f config.log
make[1]: Leaving directory '/<<PKGBUILDDIR>>'
   dh_autotools-dev_restoreconfig
dh_autotools-dev_restoreconfig: dh_autotools-dev_restoreconfig is deprecated; please see dh_autotools-dev_restoreconfig(1) for a replacement
dh_autotools-dev_restoreconfig: This feature will be removed in compat 12.
   dh_clean
 debian/rules build-arch
dh build-arch --with autotools_dev
dh: The autotools-dev sequence is deprecated and replaced by dh in debhelper (>= 9.20160115)
dh: This feature will be removed in compat 12.
   dh_update_autotools_config -a
   dh_autotools-dev_updateconfig -a
dh_autotools-dev_updateconfig: dh_autotools-dev_updateconfig is deprecated; please see dh_autotools-dev_updateconfig(1) for a replacement
dh_autotools-dev_updateconfig: This feature will be removed in compat 12.
   debian/rules override_dh_auto_configure
make[1]: Entering directory '/<<PKGBUILDDIR>>'
dh_auto_configure -- \
--with-user=greylist \
--sysconfdir=/etc/milter-greylist \
--with-conffile=/etc/milter-greylist/greylist.conf \
--with-dumpfile=/var/lib/milter-greylist/greylist.db \
--with-libspf2=/usr \
--with-libcurl=/usr \
--with-libmilter=/usr \
--with-libopendkim=/usr \
--with-libGeoIP=/usr \
--with-libbind=/usr \
--enable-dnsrbl \
--disable-rpath \
LDFLAGS=" -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro " \
CFLAGS=" -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security "
	./configure --build=x86_64-linux-gnu --prefix=/usr --includedir=\${prefix}/include --mandir=\${prefix}/share/man --infodir=\${prefix}/share/info --sysconfdir=/etc --localstatedir=/var --disable-silent-rules --libdir=\${prefix}/lib/arm-linux-gnueabihf --libexecdir=\${prefix}/lib/arm-linux-gnueabihf --disable-maintainer-mode --disable-dependency-tracking --host=arm-linux-gnueabihf --with-user=greylist --sysconfdir=/etc/milter-greylist --with-conffile=/etc/milter-greylist/greylist.conf --with-dumpfile=/var/lib/milter-greylist/greylist.db --with-libspf2=/usr --with-libcurl=/usr --with-libmilter=/usr --with-libopendkim=/usr --with-libGeoIP=/usr --with-libbind=/usr --enable-dnsrbl --disable-rpath "LDFLAGS= -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro " "CFLAGS= -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security "
configure: WARNING: unrecognized options: --disable-silent-rules, --disable-maintainer-mode, --disable-dependency-tracking
configure: loading site script /etc/dpkg-cross/cross-config.armhf
checking for arm-linux-gnueabihf-gcc... arm-linux-gnueabihf-gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... yes
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether arm-linux-gnueabihf-gcc accepts -g... yes
checking for arm-linux-gnueabihf-gcc option to accept ISO C89... none needed
checking for flex... flex
checking lex output file root... lex.yy
checking lex library... none needed
checking whether yytext is a pointer... no
checking for bison... bison -y
checking for a BSD-compatible install... /usr/bin/install -c
checking for mkdep... no
checking for rm... rm
checking for mv... mv
checking for test... test
checking for sed... sed
checking for true... true
checking for touch... touch
checking if compiler accepts -Wall... yes
checking if compiler accepts -Werror... no
checking if ld accepts -R... yes
checking if ld accepts --rpath... yes
checking for bind9_getaddresses in -lbind... no
checking for bind9_getaddresses in -lbind9... yes
checking how to run the C preprocessor... arm-linux-gnueabihf-gcc -E
checking for grep that handles long lines and -e... /bin/grep
checking for egrep... /bin/grep -E
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking arpa/inet.h usability... yes
checking arpa/inet.h presence... yes
checking for arpa/inet.h... yes
checking fcntl.h usability... yes
checking fcntl.h presence... yes
checking for fcntl.h... yes
checking netinet/in.h usability... yes
checking netinet/in.h presence... yes
checking for netinet/in.h... yes
checking for stdlib.h... (cached) yes
checking for string.h... (cached) yes
checking for strings.h... (cached) yes
checking sys/socket.h usability... yes
checking sys/socket.h presence... yes
checking for sys/socket.h... yes
checking sys/time.h usability... yes
checking sys/time.h presence... yes
checking for sys/time.h... yes
checking syslog.h usability... yes
checking syslog.h presence... yes
checking for syslog.h... yes
checking for unistd.h... (cached) yes
checking sys/param.h usability... yes
checking sys/param.h presence... yes
checking for sys/param.h... yes
checking netdb.h usability... yes
checking netdb.h presence... yes
checking for netdb.h... yes
checking getopt.h usability... yes
checking getopt.h presence... yes
checking for getopt.h... yes
checking sys/cdefs.h usability... yes
checking sys/cdefs.h presence... yes
checking for sys/cdefs.h... yes
checking arpa/nameser.h usability... yes
checking arpa/nameser.h presence... yes
checking for arpa/nameser.h... yes
checking stdbool.h usability... yes
checking stdbool.h presence... yes
checking for stdbool.h... yes
checking sys/queue.h usability... yes
checking sys/queue.h presence... yes
checking for sys/queue.h... yes
checking for pid_t... yes
checking for size_t... yes
checking whether time.h and sys/time.h may both be included... yes
checking for res_state... yes
checking if -lbind needs -lpthread to link... no
checking if -lcurl needs -lcrypto to link and run... configure: error: in `/<<PKGBUILDDIR>>':
configure: error: cannot run test program while cross compiling
See `config.log' for more details
	tail -v -n \+0 config.log
==> config.log <==
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by milter-greylist configure 4.5.11, which was
generated by GNU Autoconf 2.69.  Invocation command line was

  $ ./configure --build=x86_64-linux-gnu --prefix=/usr --includedir=${prefix}/include --mandir=${prefix}/share/man --infodir=${prefix}/share/info --sysconfdir=/etc --localstatedir=/var --disable-silent-rules --libdir=${prefix}/lib/arm-linux-gnueabihf --libexecdir=${prefix}/lib/arm-linux-gnueabihf --disable-maintainer-mode --disable-dependency-tracking --host=arm-linux-gnueabihf --with-user=greylist --sysconfdir=/etc/milter-greylist --with-conffile=/etc/milter-greylist/greylist.conf --with-dumpfile=/var/lib/milter-greylist/greylist.db --with-libspf2=/usr --with-libcurl=/usr --with-libmilter=/usr --with-libopendkim=/usr --with-libGeoIP=/usr --with-libbind=/usr --enable-dnsrbl --disable-rpath LDFLAGS= -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  CFLAGS= -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security 

## --------- ##
## Platform. ##
## --------- ##

hostname = 4be29f1fdf49
uname -m = x86_64
uname -r = 3.16.0-4-amd64
uname -s = Linux
uname -v = #1 SMP Debian 3.16.51-3 (2017-12-13)

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /usr/lib/ccache
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin
PATH: /usr/games


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2223: loading site script /etc/dpkg-cross/cross-config.armhf
| # read in package-specific and global values.
| . `dirname $ac_site_file`/cross-config.cache
| # now ensure the real architecture-dependent values take priority
| ac_cv_c_bigendian=no
| ac_cv_c_char_unsigned=yes
| ac_cv_sizeof_long_long=8
| ac_cv_sizeof_unsigned_long_long=8
| ac_cv_sizeof_long=4
| ac_cv_sizeof_unsigned_long=4
| ac_cv_sizeof_int=4
| ac_cv_sizeof_unsigned_int=4
| ac_cv_sizeof_short=2
| ac_cv_sizeof_unsigned_short=2
| ac_cv_sizeof_char=1
| ac_cv_sizeof_unsigned_char=1
| ac_cv_sizeof_signed_char=1
| ac_cv_sizeof_float=4
| ac_cv_sizeof_double=8
| ac_cv_sizeof_long_double=8
| ac_cv_sizeof_void_p=4
| ac_cv_sizeof_char_p=4
| 
| path=`dirname $ac_site_file`
| # now allow package-specific architecture-independent values to be set
| if [ -d $path/cross-config.d/armhf/ ]; then
| for file in `ls $path/cross-config.d/armhf/`; do
| 	if [ "$file" = "$PACKAGE" -o "$file" = "$PACKAGE_NAME" ]; then
| 		[ -d $path/cross-config.d/armhf/$file ] || . $path/cross-config.d/armhf/$file
| 		HAVE_PKG_CACHE=1
| 	fi
| done
| fi
| 
| if [ -z "$HAVE_PKG_CACHE" ]; then
| 	# orbit2 - only needed until liborbit-dev provides these directly
| 	# using the mechanism above.
| 	if [ "$PACKAGE" = "orbit2" -o "$PACKAGE_NAME" = "ORBit2" ]; then
| 		ac_cv_alignof_CORBA_octet=1
| 		ac_cv_alignof_CORBA_boolean=1
| 		ac_cv_alignof_CORBA_char=1
| 		ac_cv_alignof_CORBA_wchar=2
| 		ac_cv_alignof_CORBA_short=2
| 		ac_cv_alignof_CORBA_long=4
| 		ac_cv_alignof_CORBA_long_long=8
| 		ac_cv_alignof_CORBA_float=4
| 		ac_cv_alignof_CORBA_double=4
| 		ac_cv_alignof_CORBA_long_double=8
| 		ac_cv_alignof_CORBA_struct=1
| 		ac_cv_alignof_CORBA_pointer=4
| 	fi
| fi
configure:2332: checking for arm-linux-gnueabihf-gcc
configure:2348: found /usr/lib/ccache/arm-linux-gnueabihf-gcc
configure:2359: result: arm-linux-gnueabihf-gcc
configure:2628: checking for C compiler version
configure:2637: arm-linux-gnueabihf-gcc --version >&5
arm-linux-gnueabihf-gcc (Debian 8.3.0-7) 8.3.0
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:2648: $? = 0
configure:2637: arm-linux-gnueabihf-gcc -v >&5
Using built-in specs.
COLLECT_GCC=/usr/bin/arm-linux-gnueabihf-gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc-cross/arm-linux-gnueabihf/8/lto-wrapper
Target: arm-linux-gnueabihf
Configured with: ../src/configure -v --with-pkgversion='Debian 8.3.0-7' --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-multiarch --disable-sjlj-exceptions --with-arch=armv7-a --with-fpu=vfpv3-d16 --with-float=hard --with-mode=thumb --disable-werror --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=arm-linux-gnueabihf --program-prefix=arm-linux-gnueabihf- --includedir=/usr/arm-linux-gnueabihf/include
Thread model: posix
gcc version 8.3.0 (Debian 8.3.0-7) 
configure:2648: $? = 0
configure:2637: arm-linux-gnueabihf-gcc -V >&5
arm-linux-gnueabihf-gcc: error: unrecognized command line option '-V'
arm-linux-gnueabihf-gcc: fatal error: no input files
compilation terminated.
configure:2648: $? = 1
configure:2637: arm-linux-gnueabihf-gcc -qversion >&5
arm-linux-gnueabihf-gcc: error: unrecognized command line option '-qversion'; did you mean '--version'?
arm-linux-gnueabihf-gcc: fatal error: no input files
compilation terminated.
configure:2648: $? = 1
configure:2668: checking whether the C compiler works
configure:2690: arm-linux-gnueabihf-gcc  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  conftest.c  >&5
configure:2694: $? = 0
configure:2742: result: yes
configure:2745: checking for C compiler default output file name
configure:2747: result: a.out
configure:2753: checking for suffix of executables
configure:2760: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  conftest.c  >&5
configure:2764: $? = 0
configure:2786: result: 
configure:2808: checking whether we are cross compiling
configure:2846: result: yes
configure:2851: checking for suffix of object files
configure:2873: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:2877: $? = 0
configure:2898: result: o
configure:2902: checking whether we are using the GNU C compiler
configure:2921: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:2921: $? = 0
configure:2930: result: yes
configure:2939: checking whether arm-linux-gnueabihf-gcc accepts -g
configure:2959: arm-linux-gnueabihf-gcc -c -g -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:2959: $? = 0
configure:3000: result: yes
configure:3017: checking for arm-linux-gnueabihf-gcc option to accept ISO C89
configure:3080: arm-linux-gnueabihf-gcc  -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:3080: $? = 0
configure:3093: result: none needed
configure:3118: checking for flex
configure:3134: found /usr/bin/flex
configure:3145: result: flex
configure:3183: flex conftest.l
configure:3187: $? = 0
configure:3189: checking lex output file root
configure:3203: result: lex.yy
configure:3208: checking lex library
configure:3222: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  conftest.c   >&5
/usr/lib/gcc-cross/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/bin/ld: /tmp/cchQtVyu.o: in function `input':
./lex.yy.c:1180: undefined reference to `yywrap'
/usr/lib/gcc-cross/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/bin/ld: /tmp/cchQtVyu.o: in function `yylex':
./lex.yy.c:871: undefined reference to `yywrap'
/usr/lib/gcc-cross/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/bin/ld: /tmp/cchQtVyu.o: in function `main':
./conftest.l:17: undefined reference to `yywrap'
collect2: error: ld returned 1 exit status
configure:3222: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 6
| #define YY_FLEX_SUBMINOR_VERSION 4
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #ifndef SIZE_MAX
| #define SIZE_MAX               (~(size_t)0)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| /* begin standard C++ headers. */
| 
| /* TODO: this is always defined, so inline it */
| #define yyconst const
| 
| #if defined(__GNUC__) && __GNUC__ >= 3
| #define yynoreturn __attribute__((__noreturn__))
| #else
| #define yynoreturn
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an
|  *   integer in range [0..255] for use as an array index.
|  */
| #define YY_SC_TO_UI(c) ((YY_CHAR) (c))
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart( yyin  )
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #ifdef __ia64__
| /* On IA-64, the buffer size is 16k, not 8k.
|  * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
|  * Ditto for the __ia64__ case accordingly.
|  */
| #define YY_BUF_SIZE 32768
| #else
| #define YY_BUF_SIZE 16384
| #endif /* __ia64__ */
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern int yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
|     
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	int yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	int yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
| 
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static int yy_n_chars;		/* number of characters read into yy_ch_buf */
| int yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = NULL;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart ( FILE *input_file  );
| void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
| void yy_delete_buffer ( YY_BUFFER_STATE b  );
| void yy_flush_buffer ( YY_BUFFER_STATE b  );
| void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state ( void );
| 
| static void yyensure_buffer_stack ( void );
| static void yy_load_buffer_state ( void );
| static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
| #define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
| 
| void *yyalloc ( yy_size_t  );
| void *yyrealloc ( void *, yy_size_t  );
| void yyfree ( void *  );
| 
| #define yy_new_buffer yy_create_buffer
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| typedef flex_uint8_t YY_CHAR;
| 
| FILE *yyin = NULL, *yyout = NULL;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| int yylineno = 1;
| 
| extern char *yytext;
| #ifdef yytext_ptr
| #undef yytext_ptr
| #endif
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state ( void );
| static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
| static int yy_get_next_buffer ( void );
| static void yynoreturn yy_fatal_error ( const char* msg  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (int) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static const flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static const flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static const YY_CHAR yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static const YY_CHAR yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static const flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static const flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static const flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static const flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 460 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals ( void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy ( void );
| 
| int yyget_debug ( void );
| 
| void yyset_debug ( int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra ( void );
| 
| void yyset_extra ( YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in ( void );
| 
| void yyset_in  ( FILE * _in_str  );
| 
| FILE *yyget_out ( void );
| 
| void yyset_out  ( FILE * _out_str  );
| 
| 			int yyget_leng ( void );
| 
| char *yyget_text ( void );
| 
| int yyget_lineno ( void );
| 
| void yyset_lineno ( int _line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap ( void );
| #else
| extern int yywrap ( void );
| #endif
| #endif
| 
| #ifndef YY_NO_UNPUT
|     
|     static void yyunput ( int c, char *buf_ptr  );
|     
| #endif
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy ( char *, const char *, int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen ( const char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
| static int yyinput ( void );
| #else
| static int input ( void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #ifdef __ia64__
| /* On IA-64, the buffer size is 16k, not 8k */
| #define YY_READ_BUF_SIZE 16384
| #else
| #define YY_READ_BUF_SIZE 8192
| #endif /* __ia64__ */
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		int n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK /*LINTED*/break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	yy_state_type yy_current_state;
| 	char *yy_cp, *yy_bp;
| 	int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer( yyin, YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state(  );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 685 "lex.yy.c"
| 
| 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (int) ((yy_c_buf_p) - (yytext_ptr));
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| 
| find_rule: /* we branch to this label when backing up */
| 
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { /* IRIX 6.5 flex 2.5.4 underquotes its yyless argument.  */
|     yyless ((input () != 0)); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 10 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 794 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap(  ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	char *source = (yytext_ptr);
| 	int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			int num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart( yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
| 			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 		/* "- 2" to take care of EOB's */
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	yy_state_type yy_current_state;
| 	char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	int yy_is_jam;
|     
| 	YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
| #ifndef YY_NO_UNPUT
| 
|     static void yyunput (int c, char * yy_bp )
| {
| 	char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		int number_to_move = (yy_n_chars) + 2;
| 		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart( yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap(  ) )
| 						return 0;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer( yyin, YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
| 	yy_load_buffer_state(  );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state(  );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer( b, file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree( (void *) b->yy_ch_buf  );
| 
| 	yyfree( (void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer( b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state(  );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state(  );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state(  );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
|       num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		yy_size_t grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return NULL;
| 
| 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = NULL;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer( b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (const char * yystr )
| {
|     
| 	return yy_scan_bytes( yystr, (int) strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	int i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = (yy_size_t) (_yybytes_len + 2);
| 	buf = (char *) yyalloc( n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer( buf, n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yynoreturn yy_fatal_error (const char* msg )
| {
| 			fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|     
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| int yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param _line_number line number
|  * 
|  */
| void yyset_lineno (int  _line_number )
| {
|     
|     yylineno = _line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param _in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  _in_str )
| {
|         yyin = _in_str ;
| }
| 
| void yyset_out (FILE *  _out_str )
| {
|         yyout = _out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  _bdebug )
| {
|         yy_flex_debug = _bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = NULL;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = NULL;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = NULL;
|     yyout = NULL;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer( YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, const char * s2, int n )
| {
| 		
| 	int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (const char * s )
| {
| 	int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 			return malloc(size);
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 		
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return realloc(ptr, size);
| }
| 
| void yyfree (void * ptr )
| {
| 			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 10 "conftest.l"
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:3222: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  conftest.c -lfl  >&5
/usr/lib/gcc-cross/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/bin/ld: cannot find -lfl
collect2: error: ld returned 1 exit status
configure:3222: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 6
| #define YY_FLEX_SUBMINOR_VERSION 4
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #ifndef SIZE_MAX
| #define SIZE_MAX               (~(size_t)0)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| /* begin standard C++ headers. */
| 
| /* TODO: this is always defined, so inline it */
| #define yyconst const
| 
| #if defined(__GNUC__) && __GNUC__ >= 3
| #define yynoreturn __attribute__((__noreturn__))
| #else
| #define yynoreturn
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an
|  *   integer in range [0..255] for use as an array index.
|  */
| #define YY_SC_TO_UI(c) ((YY_CHAR) (c))
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart( yyin  )
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #ifdef __ia64__
| /* On IA-64, the buffer size is 16k, not 8k.
|  * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
|  * Ditto for the __ia64__ case accordingly.
|  */
| #define YY_BUF_SIZE 32768
| #else
| #define YY_BUF_SIZE 16384
| #endif /* __ia64__ */
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern int yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
|     
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	int yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	int yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
| 
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static int yy_n_chars;		/* number of characters read into yy_ch_buf */
| int yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = NULL;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart ( FILE *input_file  );
| void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
| void yy_delete_buffer ( YY_BUFFER_STATE b  );
| void yy_flush_buffer ( YY_BUFFER_STATE b  );
| void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state ( void );
| 
| static void yyensure_buffer_stack ( void );
| static void yy_load_buffer_state ( void );
| static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
| #define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
| 
| void *yyalloc ( yy_size_t  );
| void *yyrealloc ( void *, yy_size_t  );
| void yyfree ( void *  );
| 
| #define yy_new_buffer yy_create_buffer
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| typedef flex_uint8_t YY_CHAR;
| 
| FILE *yyin = NULL, *yyout = NULL;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| int yylineno = 1;
| 
| extern char *yytext;
| #ifdef yytext_ptr
| #undef yytext_ptr
| #endif
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state ( void );
| static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
| static int yy_get_next_buffer ( void );
| static void yynoreturn yy_fatal_error ( const char* msg  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (int) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static const flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static const flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static const YY_CHAR yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static const YY_CHAR yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static const flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static const flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static const flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static const flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 460 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals ( void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy ( void );
| 
| int yyget_debug ( void );
| 
| void yyset_debug ( int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra ( void );
| 
| void yyset_extra ( YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in ( void );
| 
| void yyset_in  ( FILE * _in_str  );
| 
| FILE *yyget_out ( void );
| 
| void yyset_out  ( FILE * _out_str  );
| 
| 			int yyget_leng ( void );
| 
| char *yyget_text ( void );
| 
| int yyget_lineno ( void );
| 
| void yyset_lineno ( int _line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap ( void );
| #else
| extern int yywrap ( void );
| #endif
| #endif
| 
| #ifndef YY_NO_UNPUT
|     
|     static void yyunput ( int c, char *buf_ptr  );
|     
| #endif
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy ( char *, const char *, int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen ( const char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
| static int yyinput ( void );
| #else
| static int input ( void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #ifdef __ia64__
| /* On IA-64, the buffer size is 16k, not 8k */
| #define YY_READ_BUF_SIZE 16384
| #else
| #define YY_READ_BUF_SIZE 8192
| #endif /* __ia64__ */
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		int n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK /*LINTED*/break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	yy_state_type yy_current_state;
| 	char *yy_cp, *yy_bp;
| 	int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer( yyin, YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state(  );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 685 "lex.yy.c"
| 
| 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (int) ((yy_c_buf_p) - (yytext_ptr));
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| 
| find_rule: /* we branch to this label when backing up */
| 
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { /* IRIX 6.5 flex 2.5.4 underquotes its yyless argument.  */
|     yyless ((input () != 0)); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 10 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 794 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap(  ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	char *source = (yytext_ptr);
| 	int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			int num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart( yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
| 			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 		/* "- 2" to take care of EOB's */
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	yy_state_type yy_current_state;
| 	char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	int yy_is_jam;
|     
| 	YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
| #ifndef YY_NO_UNPUT
| 
|     static void yyunput (int c, char * yy_bp )
| {
| 	char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		int number_to_move = (yy_n_chars) + 2;
| 		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart( yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap(  ) )
| 						return 0;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer( yyin, YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
| 	yy_load_buffer_state(  );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state(  );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer( b, file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree( (void *) b->yy_ch_buf  );
| 
| 	yyfree( (void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer( b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state(  );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state(  );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state(  );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
|       num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		yy_size_t grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return NULL;
| 
| 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = NULL;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer( b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (const char * yystr )
| {
|     
| 	return yy_scan_bytes( yystr, (int) strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	int i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = (yy_size_t) (_yybytes_len + 2);
| 	buf = (char *) yyalloc( n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer( buf, n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yynoreturn yy_fatal_error (const char* msg )
| {
| 			fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|     
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| int yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param _line_number line number
|  * 
|  */
| void yyset_lineno (int  _line_number )
| {
|     
|     yylineno = _line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param _in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  _in_str )
| {
|         yyin = _in_str ;
| }
| 
| void yyset_out (FILE *  _out_str )
| {
|         yyout = _out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  _bdebug )
| {
|         yy_flex_debug = _bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = NULL;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = NULL;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = NULL;
|     yyout = NULL;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer( YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, const char * s2, int n )
| {
| 		
| 	int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (const char * s )
| {
| 	int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 			return malloc(size);
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 		
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return realloc(ptr, size);
| }
| 
| void yyfree (void * ptr )
| {
| 			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 10 "conftest.l"
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:3222: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  conftest.c -ll  >&5
/usr/lib/gcc-cross/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/bin/ld: cannot find -ll
collect2: error: ld returned 1 exit status
configure:3222: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 6
| #define YY_FLEX_SUBMINOR_VERSION 4
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #ifndef SIZE_MAX
| #define SIZE_MAX               (~(size_t)0)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| /* begin standard C++ headers. */
| 
| /* TODO: this is always defined, so inline it */
| #define yyconst const
| 
| #if defined(__GNUC__) && __GNUC__ >= 3
| #define yynoreturn __attribute__((__noreturn__))
| #else
| #define yynoreturn
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an
|  *   integer in range [0..255] for use as an array index.
|  */
| #define YY_SC_TO_UI(c) ((YY_CHAR) (c))
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart( yyin  )
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #ifdef __ia64__
| /* On IA-64, the buffer size is 16k, not 8k.
|  * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
|  * Ditto for the __ia64__ case accordingly.
|  */
| #define YY_BUF_SIZE 32768
| #else
| #define YY_BUF_SIZE 16384
| #endif /* __ia64__ */
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern int yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
|     
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	int yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	int yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
| 
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static int yy_n_chars;		/* number of characters read into yy_ch_buf */
| int yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = NULL;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart ( FILE *input_file  );
| void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
| void yy_delete_buffer ( YY_BUFFER_STATE b  );
| void yy_flush_buffer ( YY_BUFFER_STATE b  );
| void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state ( void );
| 
| static void yyensure_buffer_stack ( void );
| static void yy_load_buffer_state ( void );
| static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
| #define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
| 
| void *yyalloc ( yy_size_t  );
| void *yyrealloc ( void *, yy_size_t  );
| void yyfree ( void *  );
| 
| #define yy_new_buffer yy_create_buffer
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| typedef flex_uint8_t YY_CHAR;
| 
| FILE *yyin = NULL, *yyout = NULL;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| int yylineno = 1;
| 
| extern char *yytext;
| #ifdef yytext_ptr
| #undef yytext_ptr
| #endif
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state ( void );
| static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
| static int yy_get_next_buffer ( void );
| static void yynoreturn yy_fatal_error ( const char* msg  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (int) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static const flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static const flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static const YY_CHAR yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static const YY_CHAR yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static const flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static const flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static const flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static const flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 460 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals ( void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy ( void );
| 
| int yyget_debug ( void );
| 
| void yyset_debug ( int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra ( void );
| 
| void yyset_extra ( YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in ( void );
| 
| void yyset_in  ( FILE * _in_str  );
| 
| FILE *yyget_out ( void );
| 
| void yyset_out  ( FILE * _out_str  );
| 
| 			int yyget_leng ( void );
| 
| char *yyget_text ( void );
| 
| int yyget_lineno ( void );
| 
| void yyset_lineno ( int _line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap ( void );
| #else
| extern int yywrap ( void );
| #endif
| #endif
| 
| #ifndef YY_NO_UNPUT
|     
|     static void yyunput ( int c, char *buf_ptr  );
|     
| #endif
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy ( char *, const char *, int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen ( const char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
| static int yyinput ( void );
| #else
| static int input ( void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #ifdef __ia64__
| /* On IA-64, the buffer size is 16k, not 8k */
| #define YY_READ_BUF_SIZE 16384
| #else
| #define YY_READ_BUF_SIZE 8192
| #endif /* __ia64__ */
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		int n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK /*LINTED*/break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	yy_state_type yy_current_state;
| 	char *yy_cp, *yy_bp;
| 	int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer( yyin, YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state(  );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 685 "lex.yy.c"
| 
| 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (int) ((yy_c_buf_p) - (yytext_ptr));
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| 
| find_rule: /* we branch to this label when backing up */
| 
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { /* IRIX 6.5 flex 2.5.4 underquotes its yyless argument.  */
|     yyless ((input () != 0)); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 10 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 794 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap(  ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	char *source = (yytext_ptr);
| 	int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			int num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart( yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
| 			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 		/* "- 2" to take care of EOB's */
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	yy_state_type yy_current_state;
| 	char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	int yy_is_jam;
|     
| 	YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
| #ifndef YY_NO_UNPUT
| 
|     static void yyunput (int c, char * yy_bp )
| {
| 	char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		int number_to_move = (yy_n_chars) + 2;
| 		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart( yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap(  ) )
| 						return 0;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer( yyin, YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
| 	yy_load_buffer_state(  );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state(  );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer( b, file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree( (void *) b->yy_ch_buf  );
| 
| 	yyfree( (void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer( b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state(  );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state(  );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state(  );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
|       num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		yy_size_t grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return NULL;
| 
| 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = NULL;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer( b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (const char * yystr )
| {
|     
| 	return yy_scan_bytes( yystr, (int) strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	int i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = (yy_size_t) (_yybytes_len + 2);
| 	buf = (char *) yyalloc( n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer( buf, n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yynoreturn yy_fatal_error (const char* msg )
| {
| 			fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|     
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| int yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param _line_number line number
|  * 
|  */
| void yyset_lineno (int  _line_number )
| {
|     
|     yylineno = _line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param _in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  _in_str )
| {
|         yyin = _in_str ;
| }
| 
| void yyset_out (FILE *  _out_str )
| {
|         yyout = _out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  _bdebug )
| {
|         yy_flex_debug = _bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = NULL;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = NULL;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = NULL;
|     yyout = NULL;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer( YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, const char * s2, int n )
| {
| 		
| 	int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (const char * s )
| {
| 	int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 			return malloc(size);
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 		
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return realloc(ptr, size);
| }
| 
| void yyfree (void * ptr )
| {
| 			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 10 "conftest.l"
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:3232: result: none needed
configure:3238: checking whether yytext is a pointer
configure:3255: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  conftest.c   >&5
/usr/lib/gcc-cross/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/bin/ld: /tmp/ccUia0GJ.o: in function `input':
./lex.yy.c:1180: undefined reference to `yywrap'
/usr/lib/gcc-cross/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/bin/ld: /tmp/ccUia0GJ.o: in function `yylex':
./lex.yy.c:871: undefined reference to `yywrap'
/usr/lib/gcc-cross/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/bin/ld: /tmp/ccUia0GJ.o: in function `main':
./conftest.l:17: undefined reference to `yywrap'
collect2: error: ld returned 1 exit status
configure:3255: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| 
|   #define YYTEXT_POINTER 1
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 6
| #define YY_FLEX_SUBMINOR_VERSION 4
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #ifndef SIZE_MAX
| #define SIZE_MAX               (~(size_t)0)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| /* begin standard C++ headers. */
| 
| /* TODO: this is always defined, so inline it */
| #define yyconst const
| 
| #if defined(__GNUC__) && __GNUC__ >= 3
| #define yynoreturn __attribute__((__noreturn__))
| #else
| #define yynoreturn
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an
|  *   integer in range [0..255] for use as an array index.
|  */
| #define YY_SC_TO_UI(c) ((YY_CHAR) (c))
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart( yyin  )
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #ifdef __ia64__
| /* On IA-64, the buffer size is 16k, not 8k.
|  * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
|  * Ditto for the __ia64__ case accordingly.
|  */
| #define YY_BUF_SIZE 32768
| #else
| #define YY_BUF_SIZE 16384
| #endif /* __ia64__ */
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern int yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
|     
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	int yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	int yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
| 
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static int yy_n_chars;		/* number of characters read into yy_ch_buf */
| int yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = NULL;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart ( FILE *input_file  );
| void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
| void yy_delete_buffer ( YY_BUFFER_STATE b  );
| void yy_flush_buffer ( YY_BUFFER_STATE b  );
| void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state ( void );
| 
| static void yyensure_buffer_stack ( void );
| static void yy_load_buffer_state ( void );
| static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
| #define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
| 
| void *yyalloc ( yy_size_t  );
| void *yyrealloc ( void *, yy_size_t  );
| void yyfree ( void *  );
| 
| #define yy_new_buffer yy_create_buffer
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer( yyin, YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| typedef flex_uint8_t YY_CHAR;
| 
| FILE *yyin = NULL, *yyout = NULL;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| int yylineno = 1;
| 
| extern char *yytext;
| #ifdef yytext_ptr
| #undef yytext_ptr
| #endif
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state ( void );
| static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
| static int yy_get_next_buffer ( void );
| static void yynoreturn yy_fatal_error ( const char* msg  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (int) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static const flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static const flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static const YY_CHAR yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static const YY_CHAR yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static const flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static const flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static const flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static const flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 460 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals ( void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy ( void );
| 
| int yyget_debug ( void );
| 
| void yyset_debug ( int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra ( void );
| 
| void yyset_extra ( YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in ( void );
| 
| void yyset_in  ( FILE * _in_str  );
| 
| FILE *yyget_out ( void );
| 
| void yyset_out  ( FILE * _out_str  );
| 
| 			int yyget_leng ( void );
| 
| char *yyget_text ( void );
| 
| int yyget_lineno ( void );
| 
| void yyset_lineno ( int _line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap ( void );
| #else
| extern int yywrap ( void );
| #endif
| #endif
| 
| #ifndef YY_NO_UNPUT
|     
|     static void yyunput ( int c, char *buf_ptr  );
|     
| #endif
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy ( char *, const char *, int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen ( const char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
| static int yyinput ( void );
| #else
| static int input ( void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #ifdef __ia64__
| /* On IA-64, the buffer size is 16k, not 8k */
| #define YY_READ_BUF_SIZE 16384
| #else
| #define YY_READ_BUF_SIZE 8192
| #endif /* __ia64__ */
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		int n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK /*LINTED*/break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	yy_state_type yy_current_state;
| 	char *yy_cp, *yy_bp;
| 	int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer( yyin, YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state(  );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 685 "lex.yy.c"
| 
| 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (int) ((yy_c_buf_p) - (yytext_ptr));
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| 
| find_rule: /* we branch to this label when backing up */
| 
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { /* IRIX 6.5 flex 2.5.4 underquotes its yyless argument.  */
|     yyless ((input () != 0)); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 10 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 794 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap(  ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	char *source = (yytext_ptr);
| 	int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			int num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart( yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
| 			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 		/* "- 2" to take care of EOB's */
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	yy_state_type yy_current_state;
| 	char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	int yy_is_jam;
|     
| 	YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
| #ifndef YY_NO_UNPUT
| 
|     static void yyunput (int c, char * yy_bp )
| {
| 	char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		int number_to_move = (yy_n_chars) + 2;
| 		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #endif
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart( yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap(  ) )
| 						return 0;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer( yyin, YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
| 	yy_load_buffer_state(  );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state(  );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer( b, file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree( (void *) b->yy_ch_buf  );
| 
| 	yyfree( (void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer( b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state(  );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state(  );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state(  );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
|       num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		yy_size_t grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return NULL;
| 
| 	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = NULL;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer( b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (const char * yystr )
| {
|     
| 	return yy_scan_bytes( yystr, (int) strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	int i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = (yy_size_t) (_yybytes_len + 2);
| 	buf = (char *) yyalloc( n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer( buf, n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yynoreturn yy_fatal_error (const char* msg )
| {
| 			fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|     
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| int yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param _line_number line number
|  * 
|  */
| void yyset_lineno (int  _line_number )
| {
|     
|     yylineno = _line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param _in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  _in_str )
| {
|         yyin = _in_str ;
| }
| 
| void yyset_out (FILE *  _out_str )
| {
|         yyout = _out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  _bdebug )
| {
|         yy_flex_debug = _bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = NULL;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = NULL;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = NULL;
|     yyout = NULL;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer( YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, const char * s2, int n )
| {
| 		
| 	int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (const char * s )
| {
| 	int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 			return malloc(size);
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 		
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return realloc(ptr, size);
| }
| 
| void yyfree (void * ptr )
| {
| 			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 10 "conftest.l"
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:3263: result: no
configure:3190: checking for bison
configure:3206: found /usr/bin/bison
configure:3217: result: bison -y
configure:3272: checking for a BSD-compatible install
configure:3340: result: /usr/bin/install -c
configure:3355: checking for mkdep
configure:3385: result: no
configure:3397: checking for rm
configure:3413: found /bin/rm
configure:3424: result: rm
configure:3439: checking for mv
configure:3455: found /bin/mv
configure:3466: result: mv
configure:3481: checking for test
configure:3497: found /usr/bin/test
configure:3508: result: test
configure:3523: checking for sed
configure:3539: found /bin/sed
configure:3550: result: sed
configure:3565: checking for true
configure:3581: found /bin/true
configure:3592: result: true
configure:3607: checking for touch
configure:3623: found /usr/bin/touch
configure:3634: result: touch
configure:3803: checking if compiler accepts -Wall
configure:3819: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  conftest.c  >&5
configure:3819: $? = 0
configure:3824: result: yes
configure:3829: checking if compiler accepts -Werror
configure:3845: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -Werror -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  conftest.c  >&5
configure:3845: $? = 0
configure:3850: result: no
configure:3860: checking if ld accepts -R
configure:3875: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  -Wl,-R=/ conftest.c  >&5
configure:3875: $? = 0
configure:3883: result: yes
configure:3887: checking if ld accepts --rpath
configure:3902: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  -Wl,--rpath=/ conftest.c  >&5
configure:3902: $? = 0
configure:3910: result: yes
configure:3946: checking for bind9_getaddresses in -lbind
configure:3971: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  -L/usr/lib -Wl,--rpath=/usr/lib -L/usr/lib -Wl,--rpath=/usr/lib conftest.c -lbind   >&5
/usr/lib/gcc-cross/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/bin/ld: cannot find -lbind
collect2: error: ld returned 1 exit status
configure:3971: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| #define PACKAGE_VERSION_UPSTREAM "4.5.11"
| #define PACKAGE_VERSION_SUFFIX ""
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char bind9_getaddresses ();
| int
| main ()
| {
| return bind9_getaddresses ();
|   ;
|   return 0;
| }
configure:3980: result: no
configure:3990: checking for bind9_getaddresses in -lbind9
configure:4015: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  -L/usr/lib -Wl,--rpath=/usr/lib -L/usr/lib -Wl,--rpath=/usr/lib conftest.c -lbind9   >&5
configure:4015: $? = 0
configure:4024: result: yes
configure:4863: checking how to run the C preprocessor
configure:4894: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:4894: $? = 0
configure:4908: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
conftest.c:11:10: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
          ^~~~~~~~~~~~~~~~~~
compilation terminated.
configure:4908: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| #define PACKAGE_VERSION_UPSTREAM "4.5.11"
| #define PACKAGE_VERSION_SUFFIX ""
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4933: result: arm-linux-gnueabihf-gcc -E
configure:4953: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:4953: $? = 0
configure:4967: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
conftest.c:11:10: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
          ^~~~~~~~~~~~~~~~~~
compilation terminated.
configure:4967: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| #define PACKAGE_VERSION_UPSTREAM "4.5.11"
| #define PACKAGE_VERSION_SUFFIX ""
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4996: checking for grep that handles long lines and -e
configure:5054: result: /bin/grep
configure:5059: checking for egrep
configure:5121: result: /bin/grep -E
configure:5126: checking for ANSI C header files
configure:5146: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5146: $? = 0
configure:5230: result: yes
configure:5243: checking for sys/types.h
configure:5243: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5243: $? = 0
configure:5243: result: yes
configure:5243: checking for sys/stat.h
configure:5243: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5243: $? = 0
configure:5243: result: yes
configure:5243: checking for stdlib.h
configure:5243: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5243: $? = 0
configure:5243: result: yes
configure:5243: checking for string.h
configure:5243: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5243: $? = 0
configure:5243: result: yes
configure:5243: checking for memory.h
configure:5243: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5243: $? = 0
configure:5243: result: yes
configure:5243: checking for strings.h
configure:5243: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5243: $? = 0
configure:5243: result: yes
configure:5243: checking for inttypes.h
configure:5243: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5243: $? = 0
configure:5243: result: yes
configure:5243: checking for stdint.h
configure:5243: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5243: $? = 0
configure:5243: result: yes
configure:5243: checking for unistd.h
configure:5243: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5243: $? = 0
configure:5243: result: yes
configure:5258: checking arpa/inet.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking arpa/inet.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for arpa/inet.h
configure:5258: result: yes
configure:5258: checking fcntl.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking fcntl.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for fcntl.h
configure:5258: result: yes
configure:5258: checking netinet/in.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking netinet/in.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for netinet/in.h
configure:5258: result: yes
configure:5258: checking for stdlib.h
configure:5258: result: yes
configure:5258: checking for string.h
configure:5258: result: yes
configure:5258: checking for strings.h
configure:5258: result: yes
configure:5258: checking sys/socket.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking sys/socket.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for sys/socket.h
configure:5258: result: yes
configure:5258: checking sys/time.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking sys/time.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for sys/time.h
configure:5258: result: yes
configure:5258: checking syslog.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking syslog.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for syslog.h
configure:5258: result: yes
configure:5258: checking for unistd.h
configure:5258: result: yes
configure:5258: checking sys/param.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking sys/param.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for sys/param.h
configure:5258: result: yes
configure:5258: checking netdb.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking netdb.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for netdb.h
configure:5258: result: yes
configure:5258: checking getopt.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking getopt.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for getopt.h
configure:5258: result: yes
configure:5258: checking sys/cdefs.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking sys/cdefs.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for sys/cdefs.h
configure:5258: result: yes
configure:5258: checking arpa/nameser.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking arpa/nameser.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for arpa/nameser.h
configure:5258: result: yes
configure:5258: checking stdbool.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking stdbool.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for stdbool.h
configure:5258: result: yes
configure:5258: checking sys/queue.h usability
configure:5258: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking sys/queue.h presence
configure:5258: arm-linux-gnueabihf-gcc -E -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c
configure:5258: $? = 0
configure:5258: result: yes
configure:5258: checking for sys/queue.h
configure:5258: result: yes
configure:5270: checking for pid_t
configure:5270: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5270: $? = 0
configure:5270: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
conftest.c: In function 'main':
conftest.c:74:20: error: expected expression before ')' token
 if (sizeof ((pid_t)))
                    ^
configure:5270: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| #define PACKAGE_VERSION_UPSTREAM "4.5.11"
| #define PACKAGE_VERSION_SUFFIX ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ARPA_INET_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_NETINET_IN_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYSLOG_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_NETDB_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_ARPA_NAMESER_H 1
| #define HAVE_STDBOOL_H 1
| #define HAVE_SYS_QUEUE_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((pid_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:5270: result: yes
configure:5281: checking for size_t
configure:5281: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5281: $? = 0
configure:5281: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
conftest.c: In function 'main':
conftest.c:74:21: error: expected expression before ')' token
 if (sizeof ((size_t)))
                     ^
configure:5281: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| #define PACKAGE_VERSION_UPSTREAM "4.5.11"
| #define PACKAGE_VERSION_SUFFIX ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ARPA_INET_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_NETINET_IN_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYSLOG_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_NETDB_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_ARPA_NAMESER_H 1
| #define HAVE_STDBOOL_H 1
| #define HAVE_SYS_QUEUE_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((size_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:5281: result: yes
configure:5292: checking whether time.h and sys/time.h may both be included
configure:5312: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5312: $? = 0
configure:5319: result: yes
configure:5329: checking for res_state
configure:5329: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
configure:5329: $? = 0
configure:5329: arm-linux-gnueabihf-gcc -c  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2 conftest.c >&5
conftest.c: In function 'main':
conftest.c:49:24: error: expected expression before ')' token
 if (sizeof ((res_state)))
                        ^
configure:5329: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "milter-greylist"
| #define PACKAGE_TARNAME "milter-greylist"
| #define PACKAGE_VERSION "4.5.11"
| #define PACKAGE_STRING "milter-greylist 4.5.11"
| #define PACKAGE_BUGREPORT "manu@netbsd.org"
| #define PACKAGE_URL ""
| #define PACKAGE_VERSION_UPSTREAM "4.5.11"
| #define PACKAGE_VERSION_SUFFIX ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ARPA_INET_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_NETINET_IN_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_SOCKET_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYSLOG_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_NETDB_H 1
| #define HAVE_GETOPT_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_ARPA_NAMESER_H 1
| #define HAVE_STDBOOL_H 1
| #define HAVE_SYS_QUEUE_H 1
| #define TIME_WITH_SYS_TIME 1
| /* end confdefs.h.  */
| 
| 		#include <sys/types.h>
| 		#include <netinet/in.h>
| 		#include <arpa/nameser.h>
| 		#include <resolv.h>
| 
| 
| int
| main ()
| {
| if (sizeof ((res_state)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:5329: result: yes
configure:5348: checking if -lbind needs -lpthread to link
configure:5363: arm-linux-gnueabihf-gcc -o conftest  -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP -Wdate-time -D_FORTIFY_SOURCE=2  -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  -L/usr/lib -Wl,--rpath=/usr/lib -L/usr/lib -Wl,--rpath=/usr/lib -L/usr/lib -Wl,--rpath=/usr/lib -L/usr/lib -Wl,--rpath=/usr/lib conftest.c -lGeoIP -lcurl -lbind9  >&5
configure:5363: $? = 0
configure:5391: result: no
configure:5398: checking if -lcurl needs -lcrypto to link and run
configure:5404: error: in `/<<PKGBUILDDIR>>':
configure:5406: error: cannot run test program while cross compiling
See `config.log' for more details

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_c_bigendian=no
ac_cv_c_char_unsigned=yes
ac_cv_c_compiler_gnu=yes
ac_cv_env_CC_set=
ac_cv_env_CC_value=
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=' -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security '
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value='-Wdate-time -D_FORTIFY_SOURCE=2'
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value=' -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro '
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_YACC_set=
ac_cv_env_YACC_value=
ac_cv_env_YFLAGS_set=
ac_cv_env_YFLAGS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=arm-linux-gnueabihf
ac_cv_env_target_alias_set=
ac_cv_env_target_alias_value=
ac_cv_func_malloc_0_nonnull=yes
ac_cv_func_realloc_0_nonnull=yes
ac_cv_func_setpgrp_void=yes
ac_cv_header_arpa_inet_h=yes
ac_cv_header_arpa_nameser_h=yes
ac_cv_header_fcntl_h=yes
ac_cv_header_getopt_h=yes
ac_cv_header_inttypes_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_netdb_h=yes
ac_cv_header_netinet_in_h=yes
ac_cv_header_stdbool_h=yes
ac_cv_header_stdc=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_cdefs_h=yes
ac_cv_header_sys_param_h=yes
ac_cv_header_sys_queue_h=yes
ac_cv_header_sys_socket_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_time_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_syslog_h=yes
ac_cv_header_time=yes
ac_cv_header_unistd_h=yes
ac_cv_lib_bind9_bind9_getaddresses=yes
ac_cv_lib_bind_bind9_getaddresses=no
ac_cv_lib_lex='none needed'
ac_cv_objext=o
ac_cv_path_EGREP='/bin/grep -E'
ac_cv_path_GREP=/bin/grep
ac_cv_path_install='/usr/bin/install -c'
ac_cv_prog_CC=arm-linux-gnueabihf-gcc
ac_cv_prog_CPP='arm-linux-gnueabihf-gcc -E'
ac_cv_prog_LEX=flex
ac_cv_prog_MV=mv
ac_cv_prog_RM=rm
ac_cv_prog_SED=sed
ac_cv_prog_TEST=test
ac_cv_prog_TOUCH=touch
ac_cv_prog_TRUE=true
ac_cv_prog_YACC='bison -y'
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_lex_root=lex.yy
ac_cv_prog_lex_yytext_pointer=no
ac_cv_sizeof_char=1
ac_cv_sizeof_char_p=4
ac_cv_sizeof_double=8
ac_cv_sizeof_float=4
ac_cv_sizeof_int=4
ac_cv_sizeof_long=4
ac_cv_sizeof_long_double=8
ac_cv_sizeof_long_long=8
ac_cv_sizeof_short=2
ac_cv_sizeof_signed_char=1
ac_cv_sizeof_unsigned_char=1
ac_cv_sizeof_unsigned_int=4
ac_cv_sizeof_unsigned_long=4
ac_cv_sizeof_unsigned_long_long=8
ac_cv_sizeof_unsigned_short=2
ac_cv_sizeof_void_p=4
ac_cv_type_pid_t=yes
ac_cv_type_res_state=yes
ac_cv_type_size_t=yes
lt_cv_sys_lib_dlsearch_path_spec=' /lib/arm-linux-gnueabihf /usr/lib/arm-linux-gnueabihf /lib /usr/lib /usr/local/lib'

## ----------------- ##
## Output variables. ##
## ----------------- ##

CC='arm-linux-gnueabihf-gcc'
CFLAGS=' -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wall -I/usr/include -I/usr/include/bind -I/usr/include -I/usr/include -DUSE_CURL -I/usr/include -DUSE_GEOIP'
CONFFILE=''
CPP='arm-linux-gnueabihf-gcc -E'
CPPFLAGS='-Wdate-time -D_FORTIFY_SOURCE=2'
DEFS=''
DUMPFILE=''
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/bin/grep -E'
EXEEXT=''
GREP='/bin/grep'
INSTALL_DATA='${INSTALL} -m 644'
INSTALL_PROGRAM='${INSTALL}'
INSTALL_SCRIPT='${INSTALL}'
LDFLAGS=' -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro  -L/usr/lib -Wl,--rpath=/usr/lib -L/usr/lib -Wl,--rpath=/usr/lib -L/usr/lib -Wl,--rpath=/usr/lib -L/usr/lib -Wl,--rpath=/usr/lib'
LEX='flex'
LEXLIB=''
LEX_OUTPUT_ROOT='lex.yy'
LIBOBJS=''
LIBS='-lGeoIP -lcurl -lbind9 '
LTLIBOBJS=''
MAKE_J1=''
MKDEP=''
MV='mv'
OBJEXT='o'
PACKAGE_BUGREPORT='manu@netbsd.org'
PACKAGE_NAME='milter-greylist'
PACKAGE_STRING='milter-greylist 4.5.11'
PACKAGE_TARNAME='milter-greylist'
PACKAGE_URL=''
PACKAGE_VERSION='4.5.11'
PATH_SEPARATOR=':'
RM='rm'
SED='sed'
SHELL='/bin/bash'
TEST='test'
TOUCH='touch'
TRUE='true'
USER='build'
YACC='bison -y'
YFLAGS=''
ac_ct_CC=''
bindir='${exec_prefix}/bin'
build_alias='x86_64-linux-gnu'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
exec_prefix='NONE'
host_alias='arm-linux-gnueabihf'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='${prefix}/share/info'
libdir='${prefix}/lib/arm-linux-gnueabihf'
libexecdir='${prefix}/lib/arm-linux-gnueabihf'
localedir='${datarootdir}/locale'
localstatedir='/var'
mandir='${prefix}/share/man'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s,x,x,'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='/etc/milter-greylist'
target_alias=''

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "milter-greylist"
#define PACKAGE_TARNAME "milter-greylist"
#define PACKAGE_VERSION "4.5.11"
#define PACKAGE_STRING "milter-greylist 4.5.11"
#define PACKAGE_BUGREPORT "manu@netbsd.org"
#define PACKAGE_URL ""
#define PACKAGE_VERSION_UPSTREAM "4.5.11"
#define PACKAGE_VERSION_SUFFIX ""
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define HAVE_ARPA_INET_H 1
#define HAVE_FCNTL_H 1
#define HAVE_NETINET_IN_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_STRINGS_H 1
#define HAVE_SYS_SOCKET_H 1
#define HAVE_SYS_TIME_H 1
#define HAVE_SYSLOG_H 1
#define HAVE_UNISTD_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_NETDB_H 1
#define HAVE_GETOPT_H 1
#define HAVE_SYS_CDEFS_H 1
#define HAVE_ARPA_NAMESER_H 1
#define HAVE_STDBOOL_H 1
#define HAVE_SYS_QUEUE_H 1
#define TIME_WITH_SYS_TIME 1
#define HAVE_RES_STATE 1

configure: exit 1
dh_auto_configure: ./configure --build=x86_64-linux-gnu --prefix=/usr --includedir=\${prefix}/include --mandir=\${prefix}/share/man --infodir=\${prefix}/share/info --sysconfdir=/etc --localstatedir=/var --disable-silent-rules --libdir=\${prefix}/lib/arm-linux-gnueabihf --libexecdir=\${prefix}/lib/arm-linux-gnueabihf --disable-maintainer-mode --disable-dependency-tracking --host=arm-linux-gnueabihf --with-user=greylist --sysconfdir=/etc/milter-greylist --with-conffile=/etc/milter-greylist/greylist.conf --with-dumpfile=/var/lib/milter-greylist/greylist.db --with-libspf2=/usr --with-libcurl=/usr --with-libmilter=/usr --with-libopendkim=/usr --with-libGeoIP=/usr --with-libbind=/usr --enable-dnsrbl --disable-rpath "LDFLAGS= -Wl,-z,defs -L/usr/lib/libmilter -Wl,-z,relro " "CFLAGS= -fno-strict-aliasing -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security " returned exit code 1
make[1]: *** [debian/rules:6: override_dh_auto_configure] Error 2
make[1]: Leaving directory '/<<PKGBUILDDIR>>'
make: *** [debian/rules:3: build-arch] Error 2
dpkg-buildpackage: error: debian/rules build-arch subprocess returned exit status 2
--------------------------------------------------------------------------------
Build finished at 2019-07-02T09:15:05Z

Finished
--------


+------------------------------------------------------------------------------+
| Cleanup                                                                      |
+------------------------------------------------------------------------------+

Purging /<<BUILDDIR>>
Reading package lists...
Building dependency tree...
Reading state information...
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Reading package lists...
Building dependency tree...
Reading state information...
The following package was automatically installed and is no longer required:
  sensible-utils
Use 'apt autoremove' to remove it.
The following packages will be REMOVED:
  autoconf* automake* autopoint* autotools-dev* binutils-arm-linux-gnueabihf*
  bison* bsdmainutils* cpp-8-arm-linux-gnueabihf* cpp-arm-linux-gnueabihf*
  cross-config* crossbuild-essential-armhf* debhelper* dh-autoreconf*
  dh-strip-nondeterminism* diffstat* dpkg-cross* dwz* file* flex*
  g++-8-arm-linux-gnueabihf* g++-arm-linux-gnueabihf*
  gcc-8-arm-linux-gnueabihf* gcc-8-arm-linux-gnueabihf-base* gcc-8-base:armhf*
  gcc-8-cross-base* gcc-arm-linux-gnueabihf* geoip-bin* gettext* gettext-base*
  groff-base* intltool-debian* libarchive-zip-perl* libasan5:armhf*
  libasan5-armhf-cross* libatomic1:armhf* libatomic1-armhf-cross*
  libbind-dev:armhf* libbind9-161:armhf* libbsd0* libbsd0:armhf* libc6:armhf*
  libc6-armhf-cross* libc6-dev:armhf* libc6-dev-armhf-cross* libcap2:armhf*
  libcom-err2:armhf* libconfig-auto-perl* libconfig-inifiles-perl* libcroco3*
  libcurl4:armhf* libcurl4-openssl-dev:armhf* libdb5.3:armhf*
  libdebian-dpkgcross-perl* libdns1104:armhf* libffi6:armhf*
  libfile-homedir-perl* libfile-stripnondeterminism-perl* libfile-which-perl*
  libfstrm0:armhf* libgcc-8-dev:armhf* libgcc-8-dev-armhf-cross*
  libgcc1:armhf* libgcc1-armhf-cross* libgcrypt20:armhf* libgeoip-dev:armhf*
  libgeoip1* libgeoip1:armhf* libglib2.0-0* libgmp10:armhf* libgnutls30:armhf*
  libgomp1:armhf* libgomp1-armhf-cross* libgpg-error0:armhf*
  libgssapi-krb5-2:armhf* libhogweed4:armhf* libicu63* libicu63:armhf*
  libidn2-0:armhf* libio-string-perl* libirs161:armhf* libisc1100:armhf*
  libisccc161:armhf* libisccfg163:armhf* libjson-c3:armhf* libk5crypto3:armhf*
  libkeyutils1:armhf* libkrb5-3:armhf* libkrb5support0:armhf*
  libldap-2.4-2:armhf* liblmdb0:armhf* liblocale-gettext-perl*
  liblwres161:armhf* liblzma5:armhf* libmagic-mgc* libmagic1*
  libmilter-dev:armhf* libmilter1.0.1:armhf* libncurses6* libnettle6:armhf*
  libnghttp2-14:armhf* libopendkim-dev:armhf* libopendkim11:armhf*
  libp11-kit0:armhf* libpipeline1* libprotobuf-c1:armhf* libpsl5:armhf*
  librtmp1:armhf* libsasl2-2:armhf* libsasl2-modules-db:armhf* libsigsegv2*
  libspf2-2:armhf* libspf2-dev:armhf* libssh2-1:armhf* libssl-dev:armhf*
  libssl1.1:armhf* libstdc++-8-dev:armhf* libstdc++-8-dev-armhf-cross*
  libstdc++6:armhf* libstdc++6-armhf-cross* libtasn1-6:armhf* libtool*
  libubsan1:armhf* libubsan1-armhf-cross* libuchardet0* libunistring2:armhf*
  libxml-libxml-perl* libxml-namespacesupport-perl* libxml-sax-base-perl*
  libxml-sax-perl* libxml-simple-perl* libxml2* libxml2:armhf* libyaml-perl*
  linux-libc-dev:armhf* linux-libc-dev-armhf-cross* m4* man-db* po-debconf*
  quilt* sbuild-build-depends-main-dummy:armhf* ucf* zlib1g:armhf*
0 upgraded, 0 newly installed, 142 to remove and 0 not upgraded.
After this operation, 306 MB disk space will be freed.
(Reading database ... 19540 files and directories currently installed.)
Removing sbuild-build-depends-main-dummy:armhf (0.invalid.0) ...
Removing crossbuild-essential-armhf (12.6) ...
Removing g++-arm-linux-gnueabihf (4:8.3.0-1) ...
Removing gcc-arm-linux-gnueabihf (4:8.3.0-1) ...
Removing g++-8-arm-linux-gnueabihf (8.3.0-7cross1) ...
Removing gcc-8-arm-linux-gnueabihf (8.3.0-7cross1) ...
Removing binutils-arm-linux-gnueabihf (2.31.1-16) ...
Removing bison (2:3.4.1+dfsg-2) ...
Removing quilt (0.65-3) ...
Removing cpp-arm-linux-gnueabihf (4:8.3.0-1) ...
Removing cpp-8-arm-linux-gnueabihf (8.3.0-7cross1) ...
Removing dpkg-cross (2.6.15-3) ...
Removing cross-config (2.6.15-3) ...
Removing diffstat (1.62-1) ...
Removing libdebian-dpkgcross-perl (2.6.15-3) ...
Removing flex (2.6.4-6.2) ...
Removing gcc-8-arm-linux-gnueabihf-base:amd64 (8.3.0-7cross1) ...
Removing libstdc++-8-dev:armhf (8.3.0-7) ...
Removing libgcc-8-dev:armhf (8.3.0-7) ...
Removing libubsan1:armhf (8.3.0-7) ...
Removing libbind-dev:armhf (1:9.11.5.P4+dfsg-5.1) ...
Removing liblwres161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Removing libstdc++-8-dev-armhf-cross (8.3.0-7cross1) ...
Removing libgcc-8-dev-armhf-cross (8.3.0-7cross1) ...
Removing libubsan1-armhf-cross (8.3.0-7cross1) ...
Removing libasan5-armhf-cross (8.3.0-7cross1) ...
Removing libstdc++6-armhf-cross (8.3.0-7cross1) ...
Removing libgeoip-dev:armhf (1.6.12-1) ...
Removing geoip-bin (1.6.12-1) ...
Removing libasan5:armhf (8.3.0-7) ...
Removing libatomic1:armhf (8.3.0-7) ...
Removing libatomic1-armhf-cross (8.3.0-7cross1) ...
Removing libbind9-161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Removing libopendkim-dev:armhf (2.11.0~alpha-12) ...
Removing libopendkim11:armhf (2.11.0~alpha-12) ...
Removing libbsd0:armhf (0.9.1-2) ...
Removing libcurl4-openssl-dev:armhf (7.64.0-4) ...
Removing libcurl4:armhf (7.64.0-4) ...
Removing librtmp1:armhf (2.4+20151223.gitfa8646d.1-2) ...
Removing libssh2-1:armhf (1.8.0-2.1) ...
Removing libc6-dev-armhf-cross (2.28-10cross2) ...
Removing libgomp1-armhf-cross (8.3.0-7cross1) ...
Removing libc6-dev:armhf (2.28-10) ...
Removing libirs161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Removing libisccfg163:armhf (1:9.11.5.P4+dfsg-5.1) ...
Removing libdns1104:armhf (1:9.11.5.P4+dfsg-5.1) ...
Removing libgssapi-krb5-2:armhf (1.17-3) ...
Removing libkrb5-3:armhf (1.17-3) ...
Removing libcom-err2:armhf (1.45.2-1) ...
Removing libconfig-auto-perl (0.44-1) ...
Removing libconfig-inifiles-perl (3.000001-1) ...
Removing libldap-2.4-2:armhf (2.4.47+dfsg-3) ...
Removing libsasl2-2:armhf (2.1.27+dfsg-1) ...
Removing libsasl2-modules-db:armhf (2.1.27+dfsg-1) ...
Removing libdb5.3:armhf (5.3.28+dfsg1-0.6) ...
Removing libgnutls30:armhf (3.6.7-4) ...
Removing libp11-kit0:armhf (0.23.15-2) ...
Removing libffi6:armhf (3.2.1-9) ...
Removing libfile-homedir-perl (1.004-1) ...
Removing libfile-which-perl (1.23-1) ...
Removing libisccc161:armhf (1:9.11.5.P4+dfsg-5.1) ...
Removing libisc1100:armhf (1:9.11.5.P4+dfsg-5.1) ...
Removing libfstrm0:armhf (0.4.0-1) ...
Removing libgcc1-armhf-cross (1:8.3.0-7cross1) ...
Removing libgcrypt20:armhf (1.8.4-5) ...
Removing libgeoip1:amd64 (1.6.12-1) ...
Removing libgeoip1:armhf (1.6.12-1) ...
Removing libhogweed4:armhf (3.4.1-1) ...
Removing libgmp10:armhf (2:6.1.2+dfsg-4) ...
Removing libgomp1:armhf (8.3.0-7) ...
Removing libgpg-error0:armhf (1.35-1) ...
Removing libxml-simple-perl (2.25-1) ...
Removing libxml-libxml-perl (2.0134+dfsg-1) ...
update-perl-sax-parsers: Unregistering Perl SAX parser XML::LibXML::SAX::Parser with priority 50...
update-perl-sax-parsers: Unregistering Perl SAX parser XML::LibXML::SAX with priority 50...
update-perl-sax-parsers: Updating overall Perl SAX parser modules info file...
Replacing config file /etc/perl/XML/SAX/ParserDetails.ini with new version
Removing libpsl5:armhf (0.20.2-2) ...
Removing libidn2-0:armhf (2.0.5-1) ...
Removing libio-string-perl (1.08-3) ...
Removing libjson-c3:armhf (0.12.1+ds-2) ...
Removing libk5crypto3:armhf (1.17-3) ...
Removing libkrb5support0:armhf (1.17-3) ...
Removing libkeyutils1:armhf (1.6-6) ...
Removing liblmdb0:armhf (0.9.22-1) ...
Removing liblocale-gettext-perl (1.07-3+b4) ...
Removing libmilter-dev:armhf (8.15.2-12) ...
Removing libmilter1.0.1:armhf (8.15.2-12) ...
Removing libnettle6:armhf (3.4.1-1) ...
Removing libnghttp2-14:armhf (1.37.0-1) ...
Removing libprotobuf-c1:armhf (1.3.1-1+b1) ...
Removing libspf2-dev:armhf (1.2.10-7+b5) ...
Removing libspf2-2:armhf (1.2.10-7+b5) ...
Removing libssl-dev:armhf (1.1.1c-1) ...
Removing libssl1.1:armhf (1.1.1c-1) ...
Removing libtasn1-6:armhf (4.13-3) ...
Removing libunistring2:armhf (0.9.10-1) ...
Removing libxml-sax-perl (1.00+dfsg-1) ...
update-perl-sax-parsers: Unregistering Perl SAX parser XML::SAX::PurePerl with priority 50...
update-perl-sax-parsers: Updating overall Perl SAX parser modules info file...
Removing libxml-namespacesupport-perl (1.12-1) ...
Removing libxml-sax-base-perl (1.09-1) ...
Removing libyaml-perl (1.27-1) ...
Removing linux-libc-dev:armhf (4.19.37-5) ...
Removing linux-libc-dev-armhf-cross (4.19.28-2cross2) ...
Removing ucf (3.0038+nmu1) ...
Removing libxml2:armhf (2.9.4+dfsg1-7+b3) ...
Removing libicu63:armhf (63.2-2) ...
Removing libstdc++6:armhf (8.3.0-7) ...
Removing gcc-8-cross-base (8.3.0-7cross1) ...
Removing zlib1g:armhf (1:1.2.11.dfsg-1) ...
Removing liblzma5:armhf (5.2.4-1) ...
Removing libc6-armhf-cross (2.28-10cross2) ...
Removing libcap2:armhf (1:2.25-2) ...
Removing dh-autoreconf (19) ...
Removing debhelper (12.1.1) ...
Removing dh-strip-nondeterminism (1.1.2-1) ...
Removing automake (1:1.16.1-4) ...
Removing autoconf (2.69-11) ...
Removing autopoint (0.19.8.1-9) ...
Removing libtool (2.4.6-10) ...
Removing autotools-dev (20180224.1) ...
Removing man-db (2.8.5-2) ...
Removing bsdmainutils (11.1.2+b1) ...
Removing dwz (0.12-3) ...
Removing file (1:5.35-4) ...
Removing po-debconf (1.0.21) ...
Removing intltool-debian (0.35.0+20060710.5) ...
Removing gettext (0.19.8.1-9) ...
Removing gettext-base (0.19.8.1-9) ...
Removing groff-base (1.22.4-3) ...
Removing libfile-stripnondeterminism-perl (1.1.2-1) ...
Removing libarchive-zip-perl (1.64-1) ...
Removing libbsd0:amd64 (0.9.1-2) ...
Removing libc6:armhf (2.28-10) ...
Removing libcroco3:amd64 (0.6.12-3) ...
Removing libgcc1:armhf (1:8.3.0-7) ...
Removing libglib2.0-0:amd64 (2.58.3-2) ...
Removing libxml2:amd64 (2.9.4+dfsg1-7+b3) ...
Removing libicu63:amd64 (63.2-2) ...
Removing libmagic1:amd64 (1:5.35-4) ...
Removing libmagic-mgc (1:5.35-4) ...
Removing libncurses6:amd64 (6.1+20181013-2) ...
Removing libpipeline1:amd64 (1.5.1-2) ...
Removing m4 (1.4.18-2) ...
Removing libsigsegv2:amd64 (2.12-2) ...
Removing libuchardet0:amd64 (0.0.6-3) ...
Removing gcc-8-base:armhf (8.3.0-7) ...
Processing triggers for ccache (3.7.1-1) ...
Updating symlinks in /usr/lib/ccache ...
Processing triggers for libc-bin (2.28-10) ...
(Reading database ... 12506 files and directories currently installed.)
Purging configuration files for libglib2.0-0:amd64 (2.58.3-2) ...
Purging configuration files for libssl1.1:armhf (1.1.1c-1) ...
Purging configuration files for libmagic1:amd64 (1:5.35-4) ...
Purging configuration files for quilt (0.65-3) ...
Purging configuration files for man-db (2.8.5-2) ...
Purging configuration files for libxml-sax-perl (1.00+dfsg-1) ...
Purging configuration files for cross-config (2.6.15-3) ...
Purging configuration files for bsdmainutils (11.1.2+b1) ...
Purging configuration files for libgssapi-krb5-2:armhf (1.17-3) ...
Purging configuration files for ucf (3.0038+nmu1) ...
Purging configuration files for autoconf (2.69-11) ...
Purging configuration files for libc6:armhf (2.28-10) ...
Purging configuration files for groff-base (1.22.4-3) ...
Purging configuration files for dpkg-cross (2.6.15-3) ...
Purging configuration files for libdebian-dpkgcross-perl (2.6.15-3) ...
E: Build failure (dpkg-buildpackage died)

+------------------------------------------------------------------------------+
| Summary                                                                      |
+------------------------------------------------------------------------------+

Build Architecture: amd64
Build Profiles: cross nocheck
Build Type: any
Build-Space: n/a
Build-Time: 7
Distribution: unstable-amd64-sbuild
Fail-Stage: build
Foreign Architectures: armhf
Host Architecture: armhf
Install-Time: 26
Job: /home/build/sbuild-setup/repo/pool/main/m/milter-greylist/milter-greylist_4.5.11-1.1.dsc
Machine Architecture: amd64
Package: milter-greylist
Package-Time: 38
Source-Version: 4.5.11-1.1
Space: n/a
Status: attempted
Version: 4.5.11-1.1
--------------------------------------------------------------------------------
Finished at 2019-07-02T09:15:05Z
Build needed 00:00:38, no disk space
